<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生死看淡，不服就干</title>
  
  <subtitle>计划生育养猪场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-23T14:49:55.416Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>塑料葫芦娃</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些特殊的类</title>
    <link href="http://yoursite.com/2018/04/09/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/04/09/一些特殊类/</id>
    <published>2018-04-09T15:47:44.000Z</published>
    <updated>2018-05-23T14:49:55.416Z</updated>
    
    <content type="html"><![CDATA[<h3>一些特殊的类</h3><h4>FutureTask</h4><p>该类继承自RunnableFuture，所以有Runnable和Future的特性，有run和get方法，可封装Runnable和Callable，而后可以用Executor的submit方法运行，可以一方面在异步线程中进行耗时操作的计算，然后过一段时间后再主线程中使用get方法获取相应的结果。但是get方法使用的时候回阻塞线程。</p><h4>IntentService</h4><p>用于进行耗时操作的Service，操作完成后自动停止。</p><p>是Service的子类，通过startService（intent）来传递请求，进行异步耗时操作。</p><p>使用方式：重写onHandleIntent(Intent)方法，接受请求，开启一个工作线程，单线程操作，估计有抢占机制，在8.0推荐使用JobIntentService类来代替，通过jobs来替换services</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">mServiceLooper = thread.getLooper();</span><br><span class="line">mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>/*** Unless you provide binding for your service, you don't need to implement this* method, because the default implementation returns null.* @see android.app.Service#onBind*/@Override@Nullable<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>onstartCommand -&gt; onstart -&gt; sendMessage -&gt; handleMessage -&gt; onHandleIntent</p><blockquote><p>/*** You should not override this method for your IntentService. Instead,* override {@link #onHandleIntent}, which the system calls when the IntentService* receives a start request.* @see android.app.Service#onStartCommand*/</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">     onStart(intent, startId);</span><br><span class="line">     return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用IntentService中的onHandleIntent方法，故而我们只需重写intentService中的onHandleIntent方法就可以了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">        public ServiceHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>/*** This method is invoked on the worker thread with a request to process.* Only one Intent is processed at a time, but the processing happens on a* worker thread that runs independently from other application logic.* So, if this code takes a long time, it will hold up other requests to* the same IntentService, but it will not hold up anything else.* When all requests have been handled, the IntentService stops itself,* so you should not call {@link #stopSelf}.** @param intent The value passed to {@link*               android.content.Context#startService(Intent)}.*               This may be null if the service is being restarted after*               its process has gone away; see*               {@link android.app.Service#onStartCommand}*               for details.*/</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">   protected abstract void onHandleIntent(@Nullable Intent intent);</span><br></pre></td></tr></table></figure></p><h4>HandlerThread</h4><blockquote><p>/**</p></blockquote><ul><li>Handy class for starting a new thread that has a looper. The looper can then be</li><li>used to create handler classes. Note that start() must still be called.*/</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果想在启动Looper之前做一些操作的话，可以重写下面这个方法</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Call back method that can be explicitly overridden if needed to execute some</span><br><span class="line">     * setup before Looper loops.</span><br><span class="line">     */</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;一些特殊的类&lt;/h3&gt;
&lt;h4&gt;FutureTask&lt;/h4&gt;
&lt;p&gt;该类继承自RunnableFuture，所以有Runnable和Future的特性，有run和get方法，可封装Runnable和Callable，而后可以用Executor的submit方法运行，可以
      
    
    </summary>
    
      <category term="Android源码学习" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yoursite.com/2018/04/09/OkHttp/"/>
    <id>http://yoursite.com/2018/04/09/OkHttp/</id>
    <published>2018-04-09T15:47:44.000Z</published>
    <updated>2018-05-23T14:49:55.414Z</updated>
    
    <content type="html"><![CDATA[<h3>一.基础内容</h3><h4>1.请求体</h4><p>访问协议, 响应码, 描述信息, 响应头, 响应体</p><h4>2.使用代码</h4><p>1.get同步和异步方式</p><pre><code>Request request = new Request.Builder()    .url(&quot;http://publicobject.com/helloworld.txt&quot;)    .build();Response response = client.newCall(request).execute();client.newCall(request).enqueue(new Callback() {  @Override public void onFailure(Request request, Throwable throwable) {      }  @Override public void onResponse(Response response) throws IOException {      }});</code></pre><p>2.post方式提交string</p><pre><code>String postBody = &quot;&quot;    + &quot;Releases\n&quot;    + &quot;--------\n&quot;    + &quot;\n&quot;    + &quot; * _1.0_ May 6, 2013\n&quot;    + &quot; * _1.1_ June 15, 2013\n&quot;    + &quot; * _1.2_ August 11, 2013\n&quot;;Request request = new Request.Builder()    .url(&quot;https://api.github.com/markdown/raw&quot;)    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))    .build();Response response = client.newCall(request).execute();</code></pre><p>3.post方式提交流</p><p>以流的方式POST提交请求体. 请求体的内容由流写入产生. 这个例子是流直接写入Okio的BufferedSink. 你的程序可能会使用OutputStream, 你可以使用BufferedSink.outputStream()来获取. OkHttp的底层对流和字节的操作都是基于Okio库, Okio库也是Square开发的另一个IO库, 填补I/O和NIO的空缺, 目的是提供简单便于使用的接口来操作IO.</p><pre><code>RequestBody requestBody = new RequestBody() {  @Override public MediaType contentType() {    return MEDIA_TYPE_MARKDOWN;  }  @Override public void writeTo(BufferedSink sink) throws IOException {    sink.writeUtf8(&quot;Numbers\n&quot;);    sink.writeUtf8(&quot;-------\n&quot;);    for (int i = 2; i &lt;= 997; i++) {      sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));    }  }  private String factor(int n) {    for (int i = 2; i &lt; n; i++) {      int x = n / i;      if (x * i == n) return factor(x) + &quot; × &quot; + i;    }    return Integer.toString(n);  }};</code></pre><p>4.Post方式提交文件</p><pre><code>File file = new File(&quot;README.md&quot;);RequestBody formBody=RequestBody.create(MEDIA_TYPE_MARKDOWN, file)</code></pre><p>5.Post方式提交表单</p><pre><code>RequestBody formBody = new FormBody.Builder()    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)    .build();</code></pre><p>6.Post方式提交分块请求</p><p>MultipartBody.Builder可以构建复杂的请求体, 与HTML文件上传形式兼容. 多块请求体中每块请求都是一个请求体, 可以定义自己的请求头. 这些请求头可以用来描述这块请求, 例如它的Content-Disposition. 如果Content-Length和Content-Type可用的话, 他们会被自动添加到请求头中.</p><pre><code>RequestBody requestBody = new MultipartBody.Builder()    .setType(MultipartBody.FORM)    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))    .build();Request request = new Request.Builder()    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)    .url(&quot;https://api.imgur.com/3/image&quot;)    .post(requestBody)    .build();Response response = client.newCall(request).execute();</code></pre><p>7.设置请求头</p><pre><code>Request request = new Request.Builder()    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)    .build();</code></pre><p>8.使用Gson来解析JSON响应</p><pre><code>private final Gson gson = new Gson();Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</code></pre><p>9.响应缓存</p><p>大多数程序只需要调用一次new OkHttp(), 在第一次调用时配置好缓存, 然后其他地方只需要调用这个实例就可以了. 否则两个缓存示例互相干扰, 破坏响应缓存, 而且有可能会导致程序崩溃.响应缓存使用HTTP头作为配置. 你可以在请求头中添加Cache-Control: max-stale=3600 , OkHttp缓存会支持. 你的服务通过响应头确定响应缓存多长时间, 例如使用Cache-Control: max-age=9600.</p><pre><code>int cacheSize = 10 * 1024 * 1024; // 10 MiBCache cache = new Cache(cacheDirectory, cacheSize);client = new OkHttpClient();client.setCache(cache);</code></pre><p>10.Force a Network Response or Cache</p><pre><code>connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);InputStream cached = connection.getInputStream();</code></pre><p>11.取消一个Call</p><p>使用Call.cancel()可以立即停止掉一个正在执行的call. 如果一个线程正在写请求或者读响应, 将会引发IOException. 当call没有必要的时候, 使用这个api可以节约网络资源. 例如当用户离开一个应用时, 不管同步还是异步的call都可以取消.你可以通过tags来同时取消多个请求. 当你构建一请求时, 使用RequestBuilder.tag(tag)来分配一个标签, 之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call.</p><p>12.超时</p><p>没有响应时使用超时结束call. 没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西. OkHttp支持连接超时, 读取超时和写入超时.</p><pre><code>client = new OkHttpClient.Builder()    .connectTimeout(10, TimeUnit.SECONDS)    .writeTimeout(10, TimeUnit.SECONDS)    .readTimeout(30, TimeUnit.SECONDS)    .build();</code></pre><p>13.每个Call的设置不同</p><pre><code>private final OkHttpClient client = new OkHttpClient();public void run() throws Exception {Request request = new Request.Builder()      .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.      .build();    try {      // Copy to customize OkHttp for this request.      OkHttpClient copy = client.newBuilder()          .readTimeout(500, TimeUnit.MILLISECONDS)          .build();      Response response = copy.newCall(request).execute();      System.out.println(&quot;Response 1 succeeded: &quot; + response);    } catch (IOException e) {      System.out.println(&quot;Response 1 failed: &quot; + e);    }    try {      // Copy to customize OkHttp for this request.      OkHttpClient copy = client.newBuilder()          .readTimeout(3000, TimeUnit.MILLISECONDS)          .build();      Response response = copy.newCall(request).execute();      System.out.println(&quot;Response 2 succeeded: &quot; + response);    } catch (IOException e) {      System.out.println(&quot;Response 2 failed: &quot; + e);    }}</code></pre><h3>二.源码解析</h3><p>1.OkHttpClient的内容</p><pre><code>public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {public OkHttpClient() {       this(new Builder());}OkHttpClient(Builder builder) {    this.dispatcher = builder.dispatcher;    this.proxy = builder.proxy;    this.protocols = builder.protocols;    this.connectionSpecs = builder.connectionSpecs;    this.interceptors = Util.immutableList(builder.interceptors);    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);    this.eventListenerFactory = builder.eventListenerFactory;    this.proxySelector = builder.proxySelector;    this.cookieJar = builder.cookieJar;    this.cache = builder.cache;    this.internalCache = builder.internalCache;    this.socketFactory = builder.socketFactory;    boolean isTLS = false;    ......    this.hostnameVerifier = builder.hostnameVerifier;    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(        certificateChainCleaner);    this.proxyAuthenticator = builder.proxyAuthenticator;    this.authenticator = builder.authenticator;    this.connectionPool = builder.connectionPool;    this.dns = builder.dns;    this.followSslRedirects = builder.followSslRedirects;    this.followRedirects = builder.followRedirects;    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;    this.connectTimeout = builder.connectTimeout;    this.readTimeout = builder.readTimeout;    this.writeTimeout = builder.writeTimeout;    this.pingInterval = builder.pingInterval;  }}</code></pre><p>2.Request内容</p><pre><code>Request request = new Request.Builder().url(&quot;url&quot;).build();public final class Request {    public Builder() {      this.method = &quot;GET&quot;;      this.headers = new Headers.Builder();    }    public Builder url(String url) {      ......      // Silently replace web socket URLs with HTTP URLs.      if (url.regionMatches(true, 0, &quot;ws:&quot;, 0, 3)) {        url = &quot;http:&quot; + url.substring(3);      } else if (url.regionMatches(true, 0, &quot;wss:&quot;, 0, 4)) {        url = &quot;https:&quot; + url.substring(4);      }      HttpUrl parsed = HttpUrl.parse(url);      ......      return url(parsed);    }    public Request build() {      ......      return new Request(this);    }}</code></pre><p>3.newCall( Request)</p><pre><code>public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {   @Override    public Call newCall(Request request) {    return new RealCall(this, request, false /* for web socket */);   }}</code></pre><p>RealCall实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p><p>4.异步请求</p><pre><code>final class RealCall implements Call {   @Override    public void enqueue(Callback responseCallback) {   synchronized (this) {   if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);      executed = true;   }    captureCallStackTrace();    client.dispatcher().enqueue(new AsyncCall(responseCallback));  }}</code></pre><p>由以上源码得知：</p><p>1） 检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 call#clone 方法进行克隆。</p><p>2）利用 client.dispatcher().enqueue(this) 来进行实际执行，dispatcher 是刚才看到的 OkHttpClient.Builder 的成员之一</p><p>3）AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  @Override </span><br><span class="line">  public final void run() &#123;</span><br><span class="line">   ......</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而后在其execute（）方法中使用</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          // Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          eventListener.callFailed(RealCall.this, e);</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接下来观察getResponseWithInterceptorChain（），该方法就是使用拦截器对请求进行处理</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">        originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>其中CallServerInterceptor是最后一个Interceptor，用于进行网络请求，其他的是可以对头部进行一些处理</p><p>查看chain.proceed(request)方法</p><p>AsyncCall实现了execute方法，首先是调用getResponseWithInterceptorChain()方法获取响应，然后获取成功后，就调用回调的onReponse方法，如果失败，就调用回调的onFailure方法。最后，调用Dispatcher的finished方法。</p><p>关键代码：</p><p>responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));</p><p>和</p><p>responseCallback.onResponse(RealCall.this, response);</p><p>走完这两句代码会进行回调到刚刚我们初始化Okhttp的地方</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;一.基础内容&lt;/h3&gt;
&lt;h4&gt;1.请求体&lt;/h4&gt;
&lt;p&gt;访问协议, 响应码, 描述信息, 响应头, 响应体&lt;/p&gt;
&lt;h4&gt;2.使用代码&lt;/h4&gt;
&lt;p&gt;1.get同步和异步方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Request request = new Request
      
    
    </summary>
    
      <category term="Android三方库" scheme="http://yoursite.com/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android中当item数量超过一定大小RecyclerView高度固定</title>
    <link href="http://yoursite.com/2018/04/08/Android%E4%B8%AD%E5%BD%93item%E6%95%B0%E9%87%8F%E8%B6%85%E8%BF%87%E4%B8%80%E5%AE%9A%E5%A4%A7%E5%B0%8FRecyclerView%E9%AB%98%E5%BA%A6%E5%9B%BA%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/04/08/Android中当item数量超过一定大小RecyclerView高度固定/</id>
    <published>2018-04-08T02:27:30.000Z</published>
    <updated>2018-05-23T14:49:55.412Z</updated>
    
    <content type="html"><![CDATA[<h3>Android中当item数量超过一定大小时，将RecyclerView高度固定</h3><h4>方法1</h4><blockquote><p>直接通过LayoutParams来设定相应高度</p></blockquote><pre><code>ViewGroup.LayoutParams lp = rv.getLayoutParams();if (list.size() &gt; 4) {    lp.height = DensityUtil.dip2px(mContext,32 * 4);} else {    lp.height = DensityUtil.dip2px(mContext,34 * list.size());}rv.setLayoutParams(lp);</code></pre><p>该方法只适用于item高度固定，在本例中使用34dp来设置相应的item高度，故而可以通过乘上相应的item数来计算RecyclerView的高度。</p><h4>方法2</h4><blockquote><p>重写LayoutManger的onMeasure方法，这种方式可以获取到各个item的不同高度，从而可以设置变动的高度。</p></blockquote><p><strong>在使用这种方式时，有一点需要注意的是，不要将RecyclerView的android:layout_height属性设置为wrap_content，不然是不会成功的。</strong></p><pre><code>rv.setLayoutManager(new LinearLayoutManager(mContext) {                @Override                public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) {                    int count = state.getItemCount();                    if (count &gt; 0) {                        int realHeight = 0;                        int realWidth = 0;                        for(int i = 0;i &lt; count; i++){                        View view = recycler.getViewForPosition(0);                        if (view != null) {                                measureChild(view, widthSpec, heightSpec);                                int measuredWidth = View.MeasureSpec.getSize(widthSpec);                                int measuredHeight = view.getMeasuredHeight();                                    realWidth = realWidth &gt; measuredWidth ? realWidth : measureWidth;                                realHeight += measureHeight;                                        }                            setMeasuredDimension(realWidth, realHeight);                         }                                               } else {                    super.onMeasure(recycler, state, widthSpec, heightSpec);               }           }        });</code></pre><p>方法中的recycler是一个item的循环使用器，起到对item管理的作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Android中当item数量超过一定大小时，将RecyclerView高度固定&lt;/h3&gt;
&lt;h4&gt;方法1&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;直接通过LayoutParams来设定相应高度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;ViewGrou
      
    
    </summary>
    
      <category term="java基础学习" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java线程池的4种拒绝模式</title>
    <link href="http://yoursite.com/2018/04/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%844%E4%B8%AD%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2018/04/08/Java线程池的4中拒绝策略/</id>
    <published>2018-04-08T02:27:30.000Z</published>
    <updated>2018-05-23T14:49:55.414Z</updated>
    
    <content type="html"><![CDATA[<h3>简介</h3><p>在线程池的使用中，当任务数量超出之前设定的线程池大小（既：核心线程数+等待队列大小），系统需要采取相应策略来应对新进来的任务。当前java线程池有4种不同的策略来应对这种情况。</p><h3>拒绝策略</h3><h4>1.AbortPolicy</h4><blockquote><ul><li>In the default {@link ThreadPoolExecutor.AbortPolicy}, the</li></ul></blockquote><ul><li>handler throws a runtime {@link RejectedExecutionException} upon</li><li>rejection.</li></ul><p>通过该段注释可以知道，该策略是线程池的<strong>默认策略</strong>。该策略的机制是，通过抛出一个RejectedExecutionException异常来拒绝新添加的任务。</p><pre><code>/** * A handler for rejected tasks that throws a * {@code RejectedExecutionException}. */public static class AbortPolicy implements RejectedExecutionHandler {    /**     * Creates an {@code AbortPolicy}.     */    public AbortPolicy() { }    /**     * Always throws RejectedExecutionException.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     * @throws RejectedExecutionException always     */    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +                                             &quot; rejected from &quot; +                                             e.toString());    }}</code></pre><p>只是简单的抛出一个RejectedExecutionException异常，异常中的信息是任务名和拒绝它的线程池。</p><h4>2.CallerRunsPolicy</h4><blockquote><ul><li>In {@link ThreadPoolExecutor.CallerRunsPolicy}, the thread</li></ul></blockquote><ul><li>that invokes {@code execute} itself runs the task. This provides a</li><li>simple feedback control mechanism that will slow down the rate that</li><li>new tasks are submitted.</li></ul><p>该策略直接使用当前线程来运行任务的run方法，这种方式会降低新任务的执行率。看下相应的代码：</p><pre><code>public static class CallerRunsPolicy implements RejectedExecutionHandler {    /**     * Creates a {@code CallerRunsPolicy}.     */    public CallerRunsPolicy() { }    /**     * Executes task r in the caller's thread, unless the executor     * has been shut down, in which case the task is discarded.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        if (!e.isShutdown()) {            r.run();        }    }}</code></pre><p>当过多的新任务来时，回调用rejectedExecution方法，该方法直接在任务调用者（也就是执行executor.execute(r)）所在线程中执行任务的run方法。</p><h4>DiscardPolicy</h4><blockquote><ul><li>In {@link ThreadPoolExecutor.DiscardPolicy}, a task that</li></ul></blockquote><ul><li>cannot be executed is simply dropped.</li></ul><p>通过翻译可知，该策略只是简单的将新任务抛弃，并不会抛出异常。</p><pre><code>/** * A handler for rejected tasks that silently discards the * rejected task. */public static class DiscardPolicy implements RejectedExecutionHandler {    /**     * Creates a {@code DiscardPolicy}.     */    public DiscardPolicy() { }    /**     * Does nothing, which has the effect of discarding task r.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    }}</code></pre><p>rejectedExecution方法是空的，不做任何处理。</p><h4>DiscardOldestPolicy</h4><blockquote><ul><li>In {@link ThreadPoolExecutor.DiscardOldestPolicy}, if the</li></ul></blockquote><ul><li>executor is not shut down, the task at the head of the work queue</li><li>is dropped, and then execution is retried (which can fail again,</li><li>causing this to be repeated.)</li></ul><p>该策略会将等待队列中等待最久的一个出队列，而后再次执行execute(r)方法，但是执行execute(r)方法时会有再次失败的可能，因为这里的出队列和进队列不是原子性的，在多线程环境下还是会存在别的线程先执行了execute(r)方法，将相应的任务push进等待队列中。</p><pre><code>public static class DiscardOldestPolicy implements RejectedExecutionHandler {    /**     * Creates a {@code DiscardOldestPolicy} for the given executor.     */    public DiscardOldestPolicy() { }    /**     * Obtains and ignores the next task that the executor     * would otherwise execute, if one is immediately available,     * and then retries execution of task r, unless the executor     * is shut down, in which case task r is instead discarded.     *     * @param r the runnable task requested to be executed     * @param e the executor attempting to execute this task     */    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        if (!e.isShutdown()) {            e.getQueue().poll();            e.execute(r);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;在线程池的使用中，当任务数量超出之前设定的线程池大小（既：核心线程数+等待队列大小），系统需要采取相应策略来应对新进来的任务。当前java线程池有4种不同的策略来应对这种情况。&lt;/p&gt;
&lt;h3&gt;拒绝策略&lt;/h3&gt;
&lt;h4&gt;1.AbortPolicy&lt;
      
    
    </summary>
    
      <category term="java基础学习" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>proguard</title>
    <link href="http://yoursite.com/2018/04/08/android%E6%B7%B7%E6%B7%86%E4%B8%AD%E9%9C%80%E8%A6%81keep%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2018/04/08/android混淆中需要keep的部分/</id>
    <published>2018-04-07T16:00:44.000Z</published>
    <updated>2018-05-23T14:49:55.414Z</updated>
    
    <content type="html"><![CDATA[<h4>简介</h4><blockquote><p>Proguard是一个集文件压缩,优化,混淆和校验等功能的工具它检测并删除无用的类,变量,方法和属性它优化字节码并删除无用的指令.它通过将类名,变量名和方法名重命名为无意义的名称实现混淆效果.最后它还校验处理后的代码</p></blockquote><p>保留某个包下面的类以及子包</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class com.droidyue.com.widget.**</span><br></pre></td></tr></table></figure></p><p>保留所有类中使用otto的public方法</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Otto</span><br><span class="line">-keepclassmembers class ** &#123;</span><br><span class="line">    @com.squareup.otto.Subscribe public *;</span><br><span class="line">    @com.squareup.otto.Produce public *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保留Contants类的BOOK_NAME属性</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers class com.example.admin.proguardsample.Constants &#123;</span><br><span class="line">     public static java.lang.String BOOK_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>-dontwarn</h3><blockquote><p>dontwarn是一个和keep可以说是形影不离,尤其是处理引入的library时.</p></blockquote><p>引入的library可能存在一些无法找到的引用和其他问题,在build时可能会发出警告,如果我们不进行处理,通常会导致build中止.因此为了保证build继续,我们需要使用dontwarn处理这些我们无法解决的library的警告.</p><p>比如关闭Twitter sdk的警告,我们可以这样做</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn com.twitter.sdk.**</span><br></pre></td></tr></table></figure></p><h3>哪些不应该混淆</h3><h4>反射中使用的元素</h4><blockquote><p>如果一些被混淆使用的元素(属性,方法,类,包名等)进行了混淆,可能会出现问题,如NoSuchFiledException或者NoSuchMethodException等.</p><p>想要验证,我们需要看一看混淆的映射文件,文件名为mapping.txt,该文件保存着混淆前后的映射关系.</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.example.admin.proguardsample.Constants -&gt; com.example.admin.proguardsample.a:</span><br><span class="line">    java.lang.String BOOK_NAME -&gt; a</span><br><span class="line">    void &lt;init&gt;() -&gt; &lt;init&gt;</span><br><span class="line">    void &lt;clinit&gt;() -&gt; &lt;clinit&gt;</span><br><span class="line">com.example.admin.proguardsample.MainActivity -&gt; com.example.admin.proguardsample.MainActivity:</span><br><span class="line">    void &lt;init&gt;() -&gt; &lt;init&gt;</span><br><span class="line">    void onCreate(android.os.Bundle) -&gt; onCreate</span><br></pre></td></tr></table></figure></p><h4>GSON的序列化与反序列化</h4><blockquote><p>因为反序列化创建对象本质还是利用反射,会根据json字符串的key作为属性名称,value则对应属性值.</p></blockquote><p><strong>序列化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item toSerializeItem = new Item();</span><br><span class="line">toSerializeItem.id = 2;</span><br><span class="line">toSerializeItem.name = &quot;Apple&quot;;</span><br><span class="line">String serializedText = gson.toJson(toSerializeItem);</span><br><span class="line">Log.i(LOGTAG, &quot;testGson serializedText=&quot; + serializedText);</span><br></pre></td></tr></table></figure></p><p><strong>反序列化</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new Gson();</span><br><span class="line">Item item = gson.fromJson(&quot;&#123;\&quot;id\&quot;:1, \&quot;name\&quot;:\&quot;Orange\&quot;&#125;&quot;, Item.class);</span><br><span class="line">Log.i(LOGTAG, &quot;testGson item.id=&quot; + item.id + &quot;;item.name=&quot; + item.name);</span><br></pre></td></tr></table></figure></p><ul><li>如何解决</li></ul><blockquote><p>1.将序列化和反序列化的类排除混淆2.使用@SerializedName注解字段</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Item &#123;</span><br><span class="line">    @SerializedName(&quot;name&quot;)</span><br><span class="line">    public String name;</span><br><span class="line">    @SerializedName(&quot;id&quot;)</span><br><span class="line">    public int id;</span><br></pre></td></tr></table></figure></p><h4>枚举也不要混淆</h4><p>枚举使用起来很简单,如下</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Day &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>默认的Proguard配置已经处理了枚举相关的keep操作.</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>enum文件编译后产生的class文件如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  proguardsample javap  Day</span><br><span class="line">Warning: Binary file Day contains com.example.admin.proguardsample.Day</span><br><span class="line">Compiled from &quot;Day.java&quot;</span><br><span class="line">public final class com.example.admin.proguardsample.Day extends java.lang.Enum&lt;com.example.admin.proguardsample.Day&gt; &#123;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day MONDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day TUESDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day WEDNESDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day THURSDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day FRIDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day SATURDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day SUNDAY;</span><br><span class="line">  public static com.example.admin.proguardsample.Day[] values();</span><br><span class="line">  public static com.example.admin.proguardsample.Day valueOf(java.lang.String);</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>四大组件不建议混淆</h4><blockquote><p>四大组件声明必须在manifest中注册,如果混淆后类名更改,而混淆后的类名没有在manifest注册,是不符合Android组件注册机制的.外部程序可能使用组件的字符串类名,如果类名混淆,可能导致出现异常</p></blockquote><h4>注解不能混淆</h4><blockquote><p>注解在Android平台中使用的越来越多,常用的有ButterKnife和Otto.很多场景下注解被用作在运行时反射确定一些元素的特征.</p></blockquote><blockquote><p>为了保证注解正常工作,我们不应该对注解进行混淆.Android工程默认的混淆配置已经包含了下面保留注解的配置</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure></p><h4>其他不该混淆的</h4><blockquote><p>jni调用的java方法java的native方法js调用java的方法第三方库不建议混淆其他和反射相关的一些情况</p></blockquote><p>stacktrace的恢复Proguard混淆带来了很多好处,但是也会导致我们收集到的崩溃的stacktrace变得更加难以读懂,好在有补救的措施,这里就介绍一个工具,retrace,用来将混淆后的stacktrace还原成混淆之前的信息.</p><p>retrace脚本Android 开发环境默认带着retrace脚本,一般情况下路径为./tools/proguard/bin/retrace.sh</p><p>mapping映射表Proguard进行混淆之后,会生成一个映射表,文件名为mapping.txt,我们可以使用find工具在Project下查找</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name mapping.txt</span><br><span class="line">./app/build/outputs/mapping/release/mapping.txt</span><br></pre></td></tr></table></figure></p><p>一个崩溃stacktrace信息一个原始的崩溃信息是这样的.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime(24006): Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">E/AndroidRuntime(24006):    at com.example.admin.proguardsample.a.a(Utils.java:10)</span><br><span class="line">E/AndroidRuntime(24006):    at com.example.admin.proguardsample.MainActivity.onCreate(MainActivity.java:22)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">E/AndroidRuntime(24006):    ... 10 more</span><br></pre></td></tr></table></figure></p><p>对上面的信息处理,去掉E/AndroidRuntime(24006):这些字符串retrace才能正常工作.得到的字符串是</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">at com.example.admin.proguardsample.a.a(Utils.java:10)</span><br><span class="line">at com.example.admin.proguardsample.MainActivity.onCreate(MainActivity.java:22)</span><br><span class="line">at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">... 10 more</span><br></pre></td></tr></table></figure></p><p>将上面的stacktrace保存成一个文本文件,比如名称为npe_stacktrace.txt.</p><p>开搞</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/proguard/bin/retrace.sh   /Users/admin/Downloads/ProguardSample/app/build/outputs/mapping/release/mapping.txt /tmp/npe_stacktrace.txt</span><br></pre></td></tr></table></figure></p><p>得到的易读的stacktrace是</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">at com.example.admin.proguardsample.Utils.int getBitmapWidth(android.graphics.Bitmap)(Utils.java:10)</span><br><span class="line">at com.example.admin.proguardsample.MainActivity.void onCreate(android.os.Bundle)(MainActivity.java:22)</span><br><span class="line">at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">... 10 more</span><br></pre></td></tr></table></figure></p><p>注意:为了更加容易和高效分析stacktrace,建议保留SourceFile和LineNumber属性</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;简介&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Proguard是一个集文件压缩,优化,混淆和校验等功能的工具
它检测并删除无用的类,变量,方法和属性
它优化字节码并删除无用的指令.
它通过将类名,变量名和方法名重命名为无意义的名称实现混淆效果.
最后它还校验处理后的代码
      
    
    </summary>
    
      <category term="Android基础学习" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试7</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%987/"/>
    <id>http://yoursite.com/2018/04/04/面试题7/</id>
    <published>2018-04-03T16:00:07.000Z</published>
    <updated>2018-05-23T14:49:55.418Z</updated>
    
    <content type="html"><![CDATA[<p>1.fragment预加载通过使用setUserVisibleHint和getUserVisibleHint来完成</p><pre><code>public void setUserVisibleHint(boolean isVisibleToUser) {    super.setUserVisibleHint(isVisibleToUser);    if(isVisibleToUser &amp;&amp; viewIsVisible)    initData();}onCreate(){    if (getUserVisibleHint() &amp;&amp; viewIsVisible){        initData();    }}</code></pre><p>2.Hashmap与HashTable的区别</p><pre><code>两者都是通过数组加链表的方式完成的，其中通过hashcode获取相应的hash值，而后通过该值寻找到相应链表的头，而后遍历链表获取到相应的entry对象HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。我们一put方法为例，看一看代码的细节：HashMap继承AbstractMap，HashTable继承dictionary，共同实现Serializable、Clonable，最后HashTable实现了Map，而AbstractMap实现了MapEntry对象唯一表示一个键值对，有四个属性：-K key 键对象-V value 值对象-int hash 键对象的hash值-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部也就是说HashTable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。我们知道当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀（具体证明，见这篇文章），所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。但另一方面我们又知道，在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。HashTable： 11   2*n+1HashMap：16或（2^n）   n*2我们说HashTable是同步的，HashMap不是使用new ConcurrentHashMap()，Collections.synchronizedMap(new Map)可以实现同步,其中ConcurrentHashMap使用segment将数据进行分段存储，同时为每段数据的操作进行加锁，所有速度比较快。而相对的Collections则是将相应的操作进行了synchronized加锁而已。</code></pre><p>&lt;img src=&quot;http://img.blog.csdn.net/20150528211309106&quot; alt=&quot;这里写图片描述&quot; title=&quot;&quot;&gt;</p><p>3.自定义View</p><pre><code>getMeasuredWidth()、getMeasuredHeight()必须在onMeasure之后使用才有效getWidth()与getHeight()方法必须在layout(int l, int t, int r, int b)执行之后才有效public final int getMeasuredWidth() {        return mMeasuredWidth &amp; MEASURED_SIZE_MASK;    }    public final int getMeasuredHeight() {        return mMeasuredHeight &amp; MEASURED_SIZE_MASK;    }    public final int getWidth() {        return mRight - mLeft;    }    public final int getHeight() {        return mBottom - mTop;    }    public final int getLeft() {        return mLeft;    }    public final int getRight() {        return mRight;    }    public final int getTop() {        return mTop;    }    public final int getBottom() {        return mBottom;    }整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法（这个方法巨长）开始的，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)，其核心也就是通过判断来选择顺序执行这三个方法中的哪个，如下：private void performTraversals() {    ......    //最外层的根视图的widthMeasureSpec和heightMeasureSpec由来    //lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);    ......    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);    ......    mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());    ......    mView.draw(canvas);    ......}measure方法是final，子类只能调用onMeasure方法public final void measure(int widthMeasureSpec, int heightMeasureSpec) {    ......    //回调onMeasure()方法    onMeasure(widthMeasureSpec, heightMeasureSpec);    ......}widthMeasureSpec由两部分组成，高2位表示MODE，定义在MeasureSpec类（View的内部类）中，有三种类型，MeasureSpec.EXACTLY表示确定大小， MeasureSpec.AT_MOST表示最大大小， MeasureSpec.UNSPECIFIED不确定。低30位表示size，也就是父View的大小。对于系统Window类的DecorVIew对象Mode一般都为MeasureSpec.EXACTLY ，而size分别对应屏幕宽高。对于子View来说大小是由父View和子View共同决定的。protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}public static int getDefaultSize(int size, int measureSpec) {    int result = size;    //通过MeasureSpec解析获取mode与size    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {    case MeasureSpec.UNSPECIFIED:        result = size;        break;    case MeasureSpec.AT_MOST:    case MeasureSpec.EXACTLY:        result = specSize;        break;    }    return result;}如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的规格。protected int getSuggestedMinimumWidth() {    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());}上面说了View实际是嵌套的，而且measure是递归传递的，所以每个View都需要measure。实际能够嵌套的View一般都是ViewGroup的子类，所以在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量，measureChildren内部实质只是循环调用measureChild，measureChild和measureChildWithMargins的区别就是是否把margin和padding也作为子视图的大小。如下我们以ViewGroup中稍微复杂的measureChildWithMargins方法来分析：protected void measureChildWithMargins(View child,    int parentWidthMeasureSpec, int widthUsed,    int parentHeightMeasureSpec, int heightUsed) {    //获取子视图的LayoutParams    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();    //调整MeasureSpec    //通过这两个参数以及子视图本身的LayoutParams来共同决定子视图的测量规格    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin                    + widthUsed, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin                    + heightUsed, lp.height);    //调运子View的measure方法，子View的measure中会回调子View的onMeasure方法    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}layout部分View的layout，ViewGroup的layout实际是调用View的layout public void layout(int l, int t, int r, int b) {    ......    //实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量    //判断View的位置是否发生过变化，以确定有没有必要对当前的View进行重新layout    boolean changed = isLayoutModeOptical(mParent) ?            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);    //需要重新layout    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {        //回调onLayout        onLayout(changed, l, t, r, b);        ......    }    ......}对比上面View的layout和ViewGroup的layout方法可以发现，View的layout方法是可以在子类重写的，而ViewGroup的layout是不能在子类重写的，言外之意就是说ViewGroup中只能通过重写onLayout方法。那我们接下来看下ViewGroup的onLayout方法，如下：draw部分// Step 1, draw the background, if needed// skip step 2 &amp; 5 if possible (common case)// Step 2, save the canvas' layers// Step 3, draw the content// Step 4, draw the children// Step 5, draw the fade effect and restore layers// Step 6, draw decorations (scrollbars)区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性（譬如对LinearLayout设置子View在显示时出现逐行、随机、下等显示等不同动画效果）。</code></pre><p>4.View的invalidate和postInvalidate方法源码分析</p><pre><code>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。在上面分析View的三步绘制流程中最后都有调运一个叫invalidate的方法//看见上面注释没有？public，只能在UI Thread中使用，别的Thread用postInvalidate方法，View是可见的才有效，回调onDraw方法,针对局部View public void invalidate(Rect dirty) {    final int scrollX = mScrollX;    final int scrollY = mScrollY;    //实质还是调运invalidateInternal方法    invalidateInternal(dirty.left - scrollX, dirty.top - scrollY,            dirty.right - scrollX, dirty.bottom - scrollY, true, false);}//！！！！！！看见没有，这是所有invalidate的终极调运方法！！！！！！void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,        boolean fullInvalidate) {    ......        // Propagate the damage rectangle to the parent view.        final AttachInfo ai = mAttachInfo;        final ViewParent p = mParent;        if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) {            final Rect damage = ai.mTmpInvalRect;            //设置刷新区域            damage.set(l, t, r, b);            //传递调运Parent ViewGroup的invalidateChild方法            p.invalidateChild(this, damage);        }        ......}这个过程最后传递到ViewRootImpl的invalidateChildInParent方法结束，所以我们看下ViewRootImpl的invalidateChildInParent方法， @Overridepublic ViewParent invalidateChildInParent(int[] location, Rect dirty) {    ......    //View调运invalidate最终层层上传到ViewRootImpl后最终触发了该方法    scheduleTraversals();    ......    return null;}看见没有？这个ViewRootImpl类的invalidateChildInParent方法直接返回了null，也就是上面ViewGroup中说的，层层上级传递到ViewRootImpl的invalidateChildInParent方法结束了那个do while循环。看见这里调运的scheduleTraversals这个方法吗？scheduleTraversals会通过Handler的Runnable发送一个异步消息，调运doTraversal方法，然后最终调用performTraversals()执行重绘。开头背景知识介绍说过的，performTraversals就是整个View数开始绘制的起始调运地方，所以说View调运invalidate方法的实质是层层上传到父级，直到传递到ViewRootImpl后触发了scheduleTraversals方法，然后整个View树开始重新按照上面分析的View绘制流程进行重绘任务。public void postInvalidate() {    postInvalidateDelayed(0);}public void postInvalidateDelayed(long delayMilliseconds) {    // We try only with the AttachInfo because there's no point in invalidating    // if we are not attached to our window    final AttachInfo attachInfo = mAttachInfo;    //核心，实质就是调运了ViewRootImpl.dispatchInvalidateDelayed方法    if (attachInfo != null) {        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);    }}我们继续看他调运的ViewRootImpl类的dispatchInvalidateDelayed方法，如下源码：public void dispatchInvalidateDelayed(View view, long delayMilliseconds) {    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);    mHandler.sendMessageDelayed(msg, delayMilliseconds);}看见没有，通过ViewRootImpl类的Handler发送了一条MSG_INVALIDATE消息，继续追踪这条消息的处理可以发现：public void handleMessage(Message msg) {......switch (msg.what) {case MSG_INVALIDATE:    ((View) msg.obj).invalidate();    break;......}......</code></pre><p>}</p><p>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。触发setSelection方法。请求重新draw，但只会绘制调用者本身。触发setVisibility方法。 当View可视状态在INVISIBLE转换VISIBLE时会间接调用invalidate方法，继而绘制该View。当View的可视状态在INVISIBLE\VISIBLE 转换为GONE状态时会间接调用requestLayout和invalidate方法，同时由于View树大小发生了变化，所以会请求measure过程以及draw过程，同样只绘制需要“重新绘制”的视图。触发setEnabled方法。请求重新draw，但不会重新绘制任何View包括该调用者本身。触发requestFocus方法。请求View树的draw过程，只绘制“需要重绘”的View。</p><pre><code>requestLayout方法分析 public void requestLayout() {        ......        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) {            //由此向ViewParent请求布局            //从这个View开始向上一直requestLayout，最终到达ViewRootImpl的requestLayout            mParent.requestLayout();        }        ......    }ViewRootImpl @Overridepublic void requestLayout() {    if (!mHandlingLayoutInLayoutRequest) {        checkThread();        mLayoutRequested = true;        //View调运requestLayout最终层层上传到ViewRootImpl后最终触发了该方法        scheduleTraversals();    }}看见没有，类似于上面分析的invalidate过程，只是设置的标记不同，导致对于View的绘制流程中触发的方法不同而已。requestLayout()方法会调用measure过程和layout过程，不会调用draw过程，也不会重新绘制任何View包括该调用者本身。requestLayout：当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view重新调用他的onMeasure onLayout来对重新设置自己位置。特别的当view的layoutparameter发生改变，并且它的值还没能应用到view上，这时候适合调用这个方法。invalidate：View本身调用迫使view重画。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.fragment预加载
	通过使用setUserVisibleHint和getUserVisibleHint来完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setUserVisibleHint(boolean isVisibleToUser) {
    
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试6</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%986/"/>
    <id>http://yoursite.com/2018/04/04/面试题6/</id>
    <published>2018-04-03T16:00:06.000Z</published>
    <updated>2018-05-23T14:49:55.418Z</updated>
    
    <content type="html"><![CDATA[<p>1.高效加载大图片</p><pre><code>BitmapFactory.Options options = new BitmapFactory.Options();  options.inJustDecodeBounds = true;  BitmapFactory.decodeResource(getResources(), R.id.myimage, options);  int imageHeight = options.outHeight;  int imageWidth = options.outWidth;  String imageType = options.outMimeType;  那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,      int reqWidth, int reqHeight) {      // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小      final BitmapFactory.Options options = new BitmapFactory.Options();      options.inJustDecodeBounds = true;      BitmapFactory.decodeResource(res, resId, options);      // 调用上面定义的方法计算inSampleSize值      options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);      // 使用获取到的inSampleSize值再次解析图片      options.inJustDecodeBounds = false;      return BitmapFactory.decodeResource(res, resId, options);  }  </code></pre><p>2.map的内部实现Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</p><p>3.Android 中Serializable与Parcelable区别？两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。</p><pre><code>1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&amp;~3)这句宏定义就是在做这件事情；3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder() 实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。public static final Parcelable.Creator&lt;MyColor&gt; CREATOR      = new Parcelable.Creator&lt;MyColor&gt;() {      public MyColor createFromParcel(Parcel in) {          return new MyColor(in);      }            public MyColor[] newArray(int size) {          return new MyColor[size];      }  };  MyColor(Parcel in){      color=in.readInt();  }  @Override  public void writeToParcel(Parcel dest, int flags) {      dest.writeInt(color);  }  </code></pre><p>4.Binder也与Parcel相关，都是使用的Parcel的write_和read_方法</p><pre><code>http://www.cnblogs.com/zhangxinyan/p/3487909.html客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的ublic static com.example.laozhu.aidl.Helo asInterface(proxy){return new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);}其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。这三个tree都具体存写什么东西？--&gt;这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.ProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。</code></pre><p>&lt;img src=&quot;https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png&quot; alt=&quot;&quot;&gt;</p><pre><code>this.attachInterface(this, DESCRIPTOR);而在onServiceConnected中的调用为：mService = IBookManager.Stub.asInterface(service);注意sercice为IBookManager.Stub，从而我们可以知道，我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。共享内存块</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.高效加载大图片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BitmapFactory.Options options = new BitmapFactory.Options();  
options.inJustDecodeBounds = true;  
BitmapFactor
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试5</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%985/"/>
    <id>http://yoursite.com/2018/04/04/面试题5/</id>
    <published>2018-04-03T16:00:05.000Z</published>
    <updated>2018-05-23T14:49:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>1.String、StringBuffer、StringBuilderStringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的</p><p>2.Hnadler它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。</p><pre><code>首先来看看Handler的几个常见的构造方法，分别是：Handler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。Handler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）Handler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。public Handler(Looper looper, Callback callback, boolean async)接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:定时执行messages 和 runnables；在将一个action入队并在其他线程中执行；虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 MessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。class LooperThread extends Thread {  public Handler mHandler;  public void run() {        Looper.prepare();        mHandler = new Handler() {            public void handleMessage(Message msg) {                // process incoming messages here            }        };        Looper.loop();  }}在Handler的构造方法中使用：mLooper = Looper.myLooper();//获取当前线程中的looperif (mLooper == null) {        throw new RuntimeException(            &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);    }首先是Looper.prepare()方法：sThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到其他线程，即它的值对于每个线程来说都是独立的。 Looper构造方法：    private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}在handler的构造方法中使用，获取当前线程的looper    public static Looper myLooper() {        return sThreadLocal.get();    }使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息不断地调用queue.next()从消息队列中获取消息：其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：public void More dispatchMessage(Message msg) {        if (msg.callback != null) {            handleCallback(msg);        } else {            if (mCallback != null) {                if (mCallback.handleMessage(msg)) {                    return;                }            }            handleMessage(msg);        }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.String、StringBuffer、StringBuilder
	StringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的&lt;/p&gt;
&lt;p&gt;2.Hnad
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试4</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%984/"/>
    <id>http://yoursite.com/2018/04/04/面试题4/</id>
    <published>2018-04-03T16:00:04.000Z</published>
    <updated>2018-05-23T14:49:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>1.Dalvik虚拟机与java虚拟机的区别1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</p><pre><code>2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.</code></pre><p>2.object的方法</p><pre><code>wheng fcnt</code></pre><p>3.sleep和wait的区别有</p><pre><code>其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题在java.lang.Thread类中，提供了sleep()，而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程sleep()可以将一个线程睡眠，参数可以指定一个时间。而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。1，这两个方法来自不同的类分别是Thread和Object2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用synchronized(x){  x.notify() //或者wait()}4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</code></pre><ol start="4"><li><p>Android事件分发机制完全解析</p><p>onTouch在onClick之前，onTouch返回true则onClick不响应</p><p>public boolean dispatchTouchEvent(MotionEvent event) {<br>if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;<br>mOnTouchListener.onTouch(this, event)) {<br>return true;<br>}<br>return onTouchEvent(event);<br>}</p></li></ol><pre><code>onTouchEvent方法中会调用onClick方法onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=&quot;true&quot;的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。ViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。事件传递机制  activity  -&gt; window -&gt;顶层容器(decorView) -&gt;view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。2.正常情况下，一个事件序列只能被一个View拦截且消耗。3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。6.ViewGroup默认不拦截任何事件7.View没有onInterceptTouchEvent方法8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）9.View的enable属性不影响onTouchEvent的默认返回值。10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。</code></pre><p>5.js与webView交互 &lt;script type=&quot;text/javascript&quot;&gt;<br>var result = JavaScriptInterface.jsontohtml();<br>var obj = eval(&quot;(&quot;+result+&quot;)&quot;);//解析json字符串<br>function showAndroidToast(toast)<br>{<br>JavaScriptInterface.showToast(toast);<br>}<br>function getjsonData(){<br>var result = JavaScriptInterface.jsontohtml();<br>var obj = eval(&quot;(&quot;+result+&quot;)&quot;);//解析json字符串<br>for(i=0;i&lt;obj.length;i++){<br>var user=obj[i];<br>document.write(&quot;&lt;p&gt;姓名:&quot;+user.name+&quot;&lt;/p&gt;&quot;);<br>document.write(&quot;&lt;p&gt;年龄:&quot;+user.age+&quot;&lt;/p&gt;&quot;);<br>document.write(&quot;&lt;p&gt;地址:&quot;+user.address+&quot;&lt;/p&gt;&quot;);<br>if(user.phone!=null){<br>document.write(&quot;&lt;p&gt;手机号码:&quot;+user.address+&quot;&lt;/p&gt;&quot;);<br>}<br>}<br>}<br>function list(){<br>document.write(&quot;&lt;div data-role='header'&gt;&lt;p&gt;another&lt;/p&gt;&lt;/div&gt;&quot;);<br>}<br>&lt;/script&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Dalvik虚拟机与java虚拟机的区别
	1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvi
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试3</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%983/"/>
    <id>http://yoursite.com/2018/04/04/面试题3/</id>
    <published>2018-04-03T16:00:03.000Z</published>
    <updated>2018-05-23T14:49:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>1.ContextActivity、Service、Application都是Context的子类Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。Application和Service、ContentProvider、BroadcastReceiver无法进行一下操作：1.show a Dialog2.start an Activity3.Layout Inflation</p><pre><code>启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</code></pre><p>2.JNI那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。</p><pre><code>1.Java的native方法怎么与C/C++中的函数链接起来?2.JNI定义了与Java对应的数据类型，用于JNI编程?3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。public class AndroidJni {    static{        System.loadLibrary(&quot;main&quot;);    }    public native void dynamicLog();    public native void staticLog();}这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。静态注册native方法JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog JNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法Java_PkgName_ClassName_NativeMethodName(包名+类名)两个固定的参数变量，分别是JNIEnv和jobjectJNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)jobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。动态注册JNI_OnLoad函数JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}该函数返回的int表示当前使用的JNI的版本该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：DestroyJavaVMAttachCurrentThreadDetachCurrentThreadGetEnv这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：JNIEnv *env;if (jvm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {    return -1;}这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。获取Java对象，完成动态注册上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：jclass clz = env-&gt;FindClass(&quot;com/github/songnick/jni/AndroidJni&quot;);第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：typedef struct {    const char* name;//Java层native方法的名字    const char* signature;//Java层native方法的描述符    void*       fnPtr;//对应JNI函数的指针} JNINativeMethod;JNINativeMethod nativeMethod[] = {{"dynamicLog", "()V", (void*)nativeDynamicLog}};最后调用RegisterNative函数完成动态注册：env-&gt;RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));JNIEnv结构体上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：..........jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)jboolean GetBooleanField(jobject obj, jfieldID fieldID)jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)CallVoidMethod(jobject obj, jmethodID methodID, ...)CallBooleanMethod(jobject obj, jmethodID methodID, ...)..........</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Context
	Activity、Service、Application都是Context的子类
	Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。
	Application和Service、ContentProvider、B
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试2</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>http://yoursite.com/2018/04/04/面试题2/</id>
    <published>2018-04-03T16:00:02.000Z</published>
    <updated>2018-05-23T14:49:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>1.算法冒泡排序：从后面开始，小的往上选择排序：选择最小的放到第一个插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比归并排序：分为2个一组，排序，而后在合并（N*log(N)）</p><p>2.进程保活手段黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）白色保活：启动前台Service灰色保活：利用系统的漏洞启动前台Service</p><p>3.进程间通信的方式AIDL通过bindService进行连接获取binder，数据的传送使用parcel</p><pre><code>android.os.Parcel _data = android.os.Parcel.obtain();  android.os.Parcel _reply = android.os.Parcel.obtain();  mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  Stub.TRANSACTION_add代表方法是int类型_data.writeInt(x); int t = _data.readInt();_reply.writeInt(f)服务端：binder.onTransact客户端：binder.transact广播Messenger 其实原理也是通过binder来实现的</code></pre><p>4.加载大图BitmapRegionDecoder类的使用</p><p>5.图片的3级缓存内存缓存（LruCache）int maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {<br>@Override<br>protected int sizeOf(String key, Bitmap bitmap) {<br>return bitmap.getByteCount();<br>}<br>};</p><pre><code>    照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。本地缓存（DiskLruCache）数据存放在 /sdcard/Android/data/应用包名/cache 有一个journal文件public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  open()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/&lt;application package&gt;/cache 这个路径，而后者获取到的是 /data/data/&lt;application package&gt;/cache 这个路径。（LruCache与DiskLruCache结合使用）http://blog.csdn.net/guolin_blog/article/details/34093441每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.算法
	冒泡排序：从后面开始，小的往上
	选择排序：选择最小的放到第一个
	插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比
	归并排序：分为2个一组，排序，而后在合并（N*log(N)）&lt;/p&gt;
&lt;p&gt;2.进程保活手段
	黑色保活：不同的app进程，用
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试1</title>
    <link href="http://yoursite.com/2018/04/04/%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>http://yoursite.com/2018/04/04/面试题1/</id>
    <published>2018-04-03T16:00:01.000Z</published>
    <updated>2018-05-23T14:49:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>1.4种启动方式2.service的两者启动方式：startServicebindService --&gt; 使用serviceConnection监听获取相应的binder来调用service的服务</p><p>3.BroadcastReceiver的两者注册方式：静态注册 --&gt; 生命周期与应用无关，当应用关闭时仍监听广播动态注册 --&gt; 生命周期从被注册开始到应用结束或被unregister</p><pre><code>无序广播（sendBroadcast） --&gt; 所有广播接收器同时接收广播 有序广播（sendOrderedBroadcast） --&gt; 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）</code></pre><p>4.HttpClient和HttpUrlConnection的选择在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。</p><pre><code>HttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。</code></pre><p>5.HTTP 和 HTTPS 的不同之处HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头HTTP 是不安全的，而 HTTPS 是安全的HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层HTTP 无需加密，而 HTTPS 对传输的数据进行加密HTTP 无需证书，而 HTTPS 需要认证证书</p><pre><code>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。HTTP 包含如下动作：浏览器打开一个 TCP 连接浏览器发送 HTTP 请求到服务器端服务器发送 HTTP 回应信息到浏览器TCP 连接关闭SSL 包含如下动作：验证服务器端允许客户端和服务器端选择加密算法和密码，确保双方都支持验证客户端(可选)使用公钥加密技术来生成共享加密数据创建一个加密的 SSL 连接基于该 SSL 连接传递 HTTP 请求对称密钥与非对称密钥一起使用：1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）    2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；    3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；    4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。    5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。CA（电子商务认证机构）认证作用： 在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.4种启动方式
2.service的两者启动方式：
	startService
	bindService --&amp;gt; 使用serviceConnection监听获取相应的binder来调用service的服务&lt;/p&gt;
&lt;p&gt;3.BroadcastReceiver的两者注
      
    
    </summary>
    
      <category term="Android面试" scheme="http://yoursite.com/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理</title>
    <link href="http://yoursite.com/2018/03/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/03/21/线程池/</id>
    <published>2018-03-21T06:17:44.000Z</published>
    <updated>2018-05-23T14:49:55.416Z</updated>
    
    <content type="html"><![CDATA[<h3>线程池</h3><h4>简介</h4><p>1.ExecutorService 有 submit( )、shutDown、invokeAll（与submit对应，只是多个callable的集合）</p><p>2.Future future = ExecutorService.submit(new FutureTask(callable));</p><p>2.ThreadPoolExecutor 继承自 ExecutorServcie</p><p>3.Executors 是创建ThreadPoolExecutor的工具类</p><p>4.newCachedThreadPool、newFixedThreadPool、newWorkStealingPool、newScheduledThreadPool、newSingleThreadExecutor、newSingleThreadScheduledExecutor</p><p>5.使用ThreadFactory创建thread</p><p>**When a new task is submitted in method {@link #execute(Runnable)},</p><ul><li>and fewer than corePoolSize threads are running, a new thread is</li><li>created to handle the request, even if other worker threads are</li><li>idle.  If there are more than corePoolSize but less than</li><li>maximumPoolSize threads running, a new thread will be created only</li><li>if the queue is full.  By setting corePoolSize and maximumPoolSize</li><li>the same, you create a fixed-size thread pool. By setting</li><li>maximumPoolSize to an essentially unbounded value such as {@code</li><li>Integer.MAX_VALUE}, you allow the pool to accommodate an arbitrary</li><li>number of concurrent tasks.**</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">if (addWorker(command, true))</span><br><span class="line">return;</span><br><span class="line">c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">int recheck = ctl.get();</span><br><span class="line">if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">reject(command);</span><br><span class="line">else if (workerCountOf(recheck) == 0)</span><br><span class="line">addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">reject(command);</span><br></pre></td></tr></table></figure></p><p>SynchronousQueue 没有缓冲队列，使用一一配对的方式，take和put搭配使用，有默认是不公平的，也就是后进先出LinkedBlockingQueue 对于maximumPoolSize是没有用的ArrayBlockingQueue</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量，它包含两个概念：</span><br><span class="line"></span><br><span class="line">workerCount：表明当前有效的线程数</span><br><span class="line">runState：表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying，Terminate五种状态。</span><br><span class="line">为了把这两种状态放到一个int值中保存，代码中限定了workerCount的值是2^29-1，因为还有五种状态需要表示，需要3位才能表示五种状态，所以会有29位来表示workerCount，而剩下的3位来表示当前线程池的状态。</span><br></pre></td></tr></table></figure></p><h4>几种ExecutorService的实现类</h4><p>1、newCachedThreadPool初始没有核心线程，最大线程数没有限制，使用同步队列，有60秒的idle时间，当idle时间到了而thread还没有工作的话就讲该thread销毁，线程可重用。These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.多用于运行大量的短运行周期的异步任务。</p><p>new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</p><p>2、newFixedThreadPool生成固定数量的核心线程数，最大线程数等于核心线程数Creates a thread pool that reuses a fixed number of threads</p><p>new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</p><p>3、newScheduledThreadPool</p><p>进行延迟或周期性调用任务，使用ThreadPoolExecutor进行线程池创建。内部有一个DelayedWorkQueue，该队列同时具有PriorityQueue（优先级大的元素会放到队首）和DelayQueue（如果队列里第一个元素的getDelay返回值大于0，则take调用会阻塞）的功能。将传入的任务封装成ScheduledFutureTask，该类继承FutureTaskCreates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</p><p>new ScheduledThreadPoolExecutor(corePoolSize);</p><p>4、newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</p><p>5、newSingleThreadScheduledExecutor</p><p>就是前面两者功能的结合</p><p>new DelegatedScheduledExecutorService(new ScheduledThreadPoolExecutor(1));</p><p>6、newWorkStealingPool</p><p>创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</p><p>new ForkJoinPool(parallelism,ForkJoinPool.defaultForkJoinWorkerThreadFactory,null, true);</p><p>7、ForkJoinPool</p><p>支持大任务分解成小任务的线程池，这是Java8新增线程池，通常配合ForkJoinTask接口的子类RecursiveAction或RecursiveTask使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;线程池&lt;/h3&gt;
&lt;h4&gt;简介&lt;/h4&gt;
&lt;p&gt;1.ExecutorService 有 submit( )、shutDown、invokeAll（与submit对应，只是多个callable的集合）&lt;/p&gt;
&lt;p&gt;2.Future future = ExecutorSer
      
    
    </summary>
    
      <category term="java基础学习" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>点击图标启动activity的过程</title>
    <link href="http://yoursite.com/2018/02/26/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%90%AF%E5%8A%A8activity%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/26/点击图标启动activity的过程/</id>
    <published>2018-02-26T04:02:30.000Z</published>
    <updated>2018-05-23T14:49:55.416Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif" alt="enter image description here"></p><p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p><p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p><p>3.startActivityLocked --&gt;<br>startActivityUncheckedLocked --&gt;startActivityLocked --&gt;resumeTopActivityLocked --&gt;startPausingLocked<strong>-binder-&gt;</strong><strong>ApplicationThreadProxy.schedulePauseActivity --&gt;</strong></p><p><strong>（下面的两行是message的传递）</strong>ActivityThread.queueOrSendMessage --&gt;H.handleMessage --&gt;</p><p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong></p><p><strong>-binder-&gt;</strong><strong>ActivityManagerProxy.activityPaused --&gt;</strong><strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） --&gt;</strong>ActivityStack.completePauseLocked --&gt;</p><p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) --&gt;</p><p>ActivityStack.startSpecificActivityLocked --&gt;<strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p><p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>int pid = Process.start(&quot;android.app.ActivityThread&quot;,<br>mSimpleProcessManagement ? app.processName : null, uid, uid,<br>gids, debugFlags, null);</p><p><strong>ActivityThread.main（启动ActivityThread）</strong><strong>-binder-&gt;</strong>ActivityManagerProxy.attachApplication</p><p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p><p><strong>ActivityStack.realStartActivityLocked</strong><strong>-binder-&gt;</strong><strong>ApplicationThreadProxy.scheduleLaunchActivity --&gt;</strong></p><p>ActivityThread.queueOrSendMessage --&gt;<strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong></p><p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p><p><strong>ActivityThread.performLaunchActivity --&gt;</strong></p><p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong><strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong><strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong><strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong><strong>5最后还要调用MainActivity的onCreate函数</strong></p><p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p><p>一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p><p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p><p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p><p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p><p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在ActivitySta
      
    
    </summary>
    
      <category term="Android源码学习" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫scrapy的使用</title>
    <link href="http://yoursite.com/2018/02/06/python%E7%88%AC%E8%99%ABscrapy%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/06/python爬虫scrapy的使用/</id>
    <published>2018-02-06T09:13:44.000Z</published>
    <updated>2018-05-23T14:49:55.416Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://op0dvu7tu.bkt.clouddn.com/helo005.jpg" alt="enter image description here"></p><h3>简介</h3><p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p><h3>环境与安装</h3><p><strong>环境</strong></p><p>python -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）scrapy -- 1.5.0 （这个是根据你的python版本来选择的）twistedwheelpywin32</p><p><strong>安装python</strong>这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000" target="_blank" rel="noopener">python安装</a></p><p><strong>安装scrapy</strong>一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href="https://pypi.python.org/pypi/Scrapy/1.5.0" target="_blank" rel="noopener">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p><pre><code>pip install wheel</code></pre><p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png" alt="|center"></p><p>而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png" alt="enter image description here"></p><p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png" alt="|center">经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png" alt="pywin32"><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png" alt="|center">同样使用命令行进行安装</p><pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whlpip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl</code></pre><p>安装好这些之后我们就可以来看下scrapy了<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png" alt="|center"></p><h3>scrapy初涉</h3><p>之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html</p><p>我们先通过下面命令行创建一个scrapy项目</p><pre><code>scrapy startproject heloScrapy</code></pre><p>相应的文件结构如下图所示</p><p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png" alt="|center"></p><p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。引入scrapy以及相应的request，并命名为demo</p><pre><code>import scrapyfrom tutorial.items import TutorialItemfrom scrapy.http import Requestclass DmozSpider(scrapy.Spider):    name = &quot;demo&quot;    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]    start_urls = [    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;    ]</code></pre><p>此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。</p><p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p><pre><code>    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, 'wb') as f:            f.write(response.body)        for sel in response.xpath('//ul/li'):            item = TutorialItem()            item['title'] = sel.xpath('a/text()').extract()            item['link'] = sel.xpath('a/@href').extract()            item['desc'] = sel.xpath('text()').extract()            yield item            if sel.xpath('a/@href').extract() == '':                print('empty')            else:                if len(sel.xpath('a/@href').extract()) &gt; 0:                    self.num = self.num + 1                    print('helo%s' % (self.num))                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)</code></pre><p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p><pre><code>    with open(filename, 'wb') as f:        f.write(response.body)</code></pre><p>with as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p><pre><code>file = open(&quot;/tmp/foo.txt&quot;)try:    data = file.read()finally:    file.close()</code></pre><p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p><pre><code>import scrapyclass TutorialItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    title = scrapy.Field()    link = scrapy.Field()    desc = scrapy.Field()    pass</code></pre><p>至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html</p><p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。</p><p>最后的最后就是下面这段代码了</p><pre><code> yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)</code></pre><p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p><p>最后我们可以通过cmd输入一些命令来运行程序</p><pre><code>scrapy crawl demo</code></pre><p>运行结果如下<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png" alt="enter image description here"></p><h3>总结</h3><p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://op0dvu7tu.bkt.clouddn.com/helo005.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本文将记录一次使用scrapy进行网
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫初涉</title>
    <link href="http://yoursite.com/2018/02/06/python%E6%8A%93%E5%A6%B9%E5%AD%90/"/>
    <id>http://yoursite.com/2018/02/06/python抓妹子/</id>
    <published>2018-02-06T06:17:44.000Z</published>
    <updated>2018-05-23T14:49:55.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://op0dvu7tu.bkt.clouddn.com/helo004.jpg" alt="enter image description here"></p><h3>文章简介</h3><p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p><p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png" alt="enter image description here"></p><p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p><h3>环境介绍</h3><p>废话少说接下来就是我们的基础环境部分<strong>1.Python -- 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p><p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p><p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下）</p><p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页</p><hr><p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p><hr><p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p><p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p><h3>模块的安装</h3><p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\python36”和“文件夹\python36\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p><p><strong>接下来就用指令安装模块</strong></p><pre><code> pip install requests    pip install beautifulsoup4   pip install lxml</code></pre><p>大致结果就如下图所示<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png" alt="enter image description here"></p><p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p><h3>爬虫编写</h3><p><strong>首先我们先整理一下爬图片的步骤：</strong></p><p>1.我们需要一个目标网站（www.mzitu.com）2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取3.获取网页中的图片地址4.下载图片到本地</p><p><strong>步骤1：</strong>www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png" alt="enter image description here"></p><p><strong>步骤2：</strong>推荐使用chrome浏览器来进行网页源码的查看<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png" alt="enter image description here"></p><p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p><p><strong>步骤3：</strong>接下来我们就进入到某个链接里面去看图了<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png" alt="enter image description here">相应图片的地址被包含在**div class='main-image'**中</p><p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png" alt="enter image description here">着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在**div class=‘pagenavi’**中</p><p><strong>步骤4：</strong><strong>开始代码编写</strong></p><p>我们需要在代码中引入相应的模块</p><pre><code>import requestsfrom bs4 import BeautifulSoupimport os</code></pre><p>获取起始网页内容</p><pre><code>html = self.request(url)</code></pre><p>这里的request是下面的这个方法</p><pre><code>    def request(self, url):  ##这个函数获取网页的response 然后返回        headers = {        'User-Agent': &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}        content = requests.get(url, headers=headers)        return content</code></pre><p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p><pre><code>all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')for a in all_a:           title = a.get_text() #取出a标签的文本           href = a['href'] #取出a标签的href 属性，也就是套图地址    self.html(href, &quot;e:\\pic\\&quot; + path)</code></pre><p>相应的html方法</p><pre><code>    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址        html = self.request(href)        helo = BeautifulSoup(html.text, 'lxml').find_all('span')        if len(helo) &lt; 10:            return        max_span = helo[10].get_text()        for page in range(1, int(max_span) + 1):            page_url = href + '/' + str(page)            self.img(page_url, path)  ##调用img函数</code></pre><p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p><pre><code>    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址        img_html = self.request(page_url)        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')        if helo is not None:            helo1 = helo.find('img')            if helo1 is not None:                # do some thing you need                img_url = helo1['src']                self.saveImg(img_url, path)    def saveImg(self, url, path):        getHeaders = {            'Host': 'i.meizitu.net',            'Connection': 'Keep-Alive',            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',            'Upgrade-Insecure-Requests': '1',            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',            'Referer': 'http://www.mzitu.com/',            'Accept-Encoding': 'gzip, deflate',            'Accept-Language': 'zh-CN,zh;q=0.9'        }        response = requests.get(url, headers=getHeaders)                if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取            response = requests.get(url, headers=getHeaders, allow_redirects=False)            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。                name = url[-9:-4]                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址                response = requests.get(redirectUrl)                fp = open(name + &quot;.jpg&quot;, 'ab')                fp.write(response.content)                fp.close()        else:            os.chdir(path)            name = url[-9:-4]            fp = open(name + &quot;.jpg&quot;, 'ab')            fp.write(response.content)            fp.close()            self.picNum = self.picNum + 1            print(self.picNum)</code></pre><p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p><h3>总结</h3><p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p><p><strong>多线程代码</strong></p><pre><code>import requestsfrom bs4 import BeautifulSoupimport osimport threadingimport threadpoolclass mzitu():    num = 0    picNum = 0    def all_url(self, url):        self.cv = threading.Condition()        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')        task_pool = threadpool.ThreadPool(50)        requests = threadpool.makeRequests(self.nice, all_a)        for req in requests:            task_pool.putRequest(req)        task_pool.wait()    def nice(self, a):        title = a.get_text()        path = str(title).replace(&quot;?&quot;, '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！            os.chdir(&quot;e:\\pic\\&quot; + path)  ##切换到目录            href = a['href']            self.html(href, &quot;e:\\pic\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址        html = self.request(href)        helo = BeautifulSoup(html.text, 'lxml').find_all('span')        if len(helo) &lt; 10:            return        max_span = helo[10].get_text()        for page in range(1, int(max_span) + 1):            page_url = href + '/' + str(page)            self.img(page_url, path)  ##调用img函数    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址        img_html = self.request(page_url)        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')        if helo is not None:            helo1 = helo.find('img')            if helo1 is not None:                # do some thing you need                img_url = helo1['src']                self.saveImg(img_url, path)    def mkdir(self, path):  ##这个函数创建文件夹        path = path.strip()        if path.__contains__(&quot;妲己&quot;):            return False        isExists = os.path.exists(os.path.join(&quot;e:\\pic\\&quot;, path))        if not isExists:            os.makedirs(os.path.join(&quot;e:\\pic\\&quot;, path))            return True        else:            return False    def request(self, url):  ##这个函数获取网页的response 然后返回        headers = {            'User-Agent': &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}        content = requests.get(url, headers=headers)        return content    def saveImg(self, url, path):        getHeaders = {            'Host': 'i.meizitu.net',            'Connection': 'Keep-Alive',            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',            'Upgrade-Insecure-Requests': '1',            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',            'Referer': 'http://www.mzitu.com/',            'Accept-Encoding': 'gzip, deflate',            'Accept-Language': 'zh-CN,zh;q=0.9'        }        response = requests.get(url, headers=getHeaders)        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取            response = requests.get(url, headers=getHeaders, allow_redirects=False)            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。                name = url[-9:-4]                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址                response = requests.get(redirectUrl)                fp = open(name + &quot;.jpg&quot;, 'ab')                fp.write(response.content)                fp.close()        else:            os.chdir(path)            name = url[-9:-4]            fp = open(name + &quot;.jpg&quot;, 'ab')            fp.write(response.content)            fp.close()            self.picNum = self.picNum + 1            print(self.picNum)            Mzitu = mzitu()  ##实例化Mzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://op0dvu7tu.bkt.clouddn.com/helo004.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
&lt;h3&gt;文章简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本文将介绍如何使用python对
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android自动化测试</title>
    <link href="http://yoursite.com/2016/06/01/Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2016/06/01/Android自动化测试/</id>
    <published>2016-06-01T15:47:44.000Z</published>
    <updated>2018-05-23T14:49:55.413Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg" alt="enter image description here"></p><hr><h3>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。</code></pre><h3>Monkey测试</h3><h4>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  </code></pre><h4>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   （2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  （3）Monkey 命令启动方式：        - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试      - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器      - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         </code></pre><h4>效果展示</h4><p>部分输出数据如下所示：<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png" alt="输出数据"></p><h4>更多参数介绍</h4><p><a href="http://blog.csdn.net/linghu_java/article/details/6732895" target="_blank" rel="noopener">点击查看</a></p><h4>可能会遇到的问题</h4><pre><code>（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  </code></pre><p><a href="http://www.cnblogs.com/dwf07223/p/3228047.html" target="_blank" rel="noopener">点击查看解决方案</a></p><h3>单元测试</h3><h4>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。</code></pre><h4>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：dependencies {    testCompile 'junit:junit:4.12'}</code></pre><p>而后在test文件下写单元测试类<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png" alt="enter image description here"></p><p>被测试类如下</p><pre><code>public class Calculator {    public static int add(int a, int b) {        return a + b;    }}</code></pre><p>单元测试类如下</p><pre><code>public class ExampleUnitTest {    @Test    public void addition_isCorrect() throws Exception {        assertEquals(4, Calculator.add(2,2));    }}</code></pre><p>最后运行单元测试类，结果如下：</p><p><img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png" alt="enter image description here"></p><h4>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p><pre><code>@Test： 将方法（函数）标记为测试用例@Before： 每一个使用@Test标记的方法运行之前都要运行一次@After： 每一个使用@Test标记的方法运行之后都要运行一次@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次</code></pre><p>以如下代码为例：</p><pre><code>public class ExampleUnitTest {    @Test    public void addition_isCorrect() throws Exception {        System.out.println(&quot;@Test&quot;);    }    @Test    public void addition_isErr() throws Exception {        System.out.println(&quot;@Test&quot;);    }    @Before    public void before() throws Exception {        System.out.println(&quot;@Before&quot;);    }    @After    public void after() throws Exception {        System.out.println(&quot;@After&quot;);    }    @AfterClass    public static void afterClass() throws Exception {        System.out.println(&quot;@AfterClass&quot;);    }    @BeforeClass    public static void beforeClass() throws Exception {        System.out.println(&quot;@BeforeClass&quot;);    }}</code></pre><p>相应的执行顺序如下：<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png" alt="enter image description here"></p><h4>Mockito使用方式</h4><p>简介：</p><pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。</code></pre><p><strong>先体验以下Mockito的使用：</strong></p><p>1.添加依赖</p><pre><code>testCompile 'org.mockito:mockito-core:2.8.47'</code></pre><p>2.被依赖类</p><pre><code>public interface IMathUtils {    public int abs(int num); // 求绝对值}</code></pre><p>3.依赖类</p><pre><code>@RunWith(MockitoJUnitRunner.class)public class MockTest {    @Mock    IMathUtils mathUtils;    @Test    public void mockTest() {        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1        int abs = mathUtils.abs(-1); // 输出结果 1        Assert.assertEquals(abs, 1);// 测试通过    }}</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p><p>Mockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p><p>上述的依赖类也可以使用如下方式来写：</p><pre><code>public class MockTest {    @Mock    IMathUtils iMathUtils ;     @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();     @Test    public void mockTest()  {        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1        int abs = mathUtils.abs(-1); // 输出结果 1        Assert.assertEquals(abs, 1);// 测试通过    }}</code></pre><p>其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似</p><p><strong>Mock配置</strong></p><p>Mock有多种配置方式，如下所示：</p><pre><code>@Testpublic void test1()  {        //  创建 mock        MyClass test = Mockito.mock(MyClass.class);    // 自定义 getUniqueId() 的返回值    when(test.getUniqueId()).thenReturn(43);    // 在测试中使用mock对象    assertEquals(test.getUniqueId(), 43);}// 返回多个值@Testpublic void testMoreThanOneReturnValue()  {        Iterator i= mock(Iterator.class);        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);        String result=i.next()+&quot; &quot;+i.next();        // 断言        assertEquals(&quot;Mockito rocks&quot;, result);}// 如何根据输入来返回值@Testpublic void testReturnValueDependentOnMethodParameter()  {        Comparable c= mock(Comparable.class);        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);        // 断言        assertEquals(1,c.compareTo(&quot;Mockito&quot;));}// 如何让返回值不依赖于输入@Testpublic void testReturnValueInDependentOnMethodParameter()  {        Comparable c= mock(Comparable.class);        when(c.compareTo(anyInt())).thenReturn(-1);        // 断言        assertEquals(-1 ,c.compareTo(9));}// 根据参数类型来返回值@Testpublic void testReturnValueInDependentOnMethodParameter()  {        Comparable c= mock(Comparable.class);        when(c.compareTo(isA(Todo.class))).thenReturn(0);        // 断言        Todo todo = new Todo(5);        assertEquals(todo ,c.compareTo(new Todo(1)));}</code></pre><p>更多配置可以看下这个网站  <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html" target="_blank" rel="noopener">点击链接</a></p><h3>UI测试</h3><h4>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。</code></pre><h4>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p><pre><code>testCompile 'com.android.support.test.espresso:espresso-core:2.2.2'testCompile 'com.android.support.test:runner:0.4.1'</code></pre><p>2.在androidTest目录下创建测试类</p><p><img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png" alt="enter image description here"></p><p>3.被测试类（即activity之类的展示界面）MainActivity.class</p><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{    private EditText mEt;    private TextView mTv;    private Button mBtn;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mEt = (EditText) findViewById(R.id.et);        mTv = (TextView) findViewById(R.id.tv);        mBtn = (Button) findViewById(R.id.btn);        mBtn.setOnClickListener(this);    }    @Override    public void onClick(View v) {        mTv.setText(mEt.getText().toString());    }}</code></pre><p>activity_main.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;&lt;TextView    android:id=&quot;@+id/tv&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginTop=&quot;15dp&quot;    android:padding=&quot;10dp&quot;    android:text=&quot;helo&quot; /&gt;&lt;EditText    android:id=&quot;@+id/et&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;40dp&quot;    android:layout_alignParentLeft=&quot;true&quot;    android:layout_alignParentStart=&quot;true&quot;    android:layout_alignParentTop=&quot;true&quot;    android:layout_marginTop=&quot;75dp&quot; /&gt;&lt;Button    android:id=&quot;@+id/btn&quot;    android:layout_width=&quot;80dp&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_below=&quot;@+id/et&quot;    android:layout_centerHorizontal=&quot;true&quot;    android:layout_marginTop=&quot;49dp&quot;    android:text=&quot;sure&quot; /&gt;&lt;/RelativeLayout&gt;</code></pre><p>测试类ExampleInstrumentedTest.class</p><pre><code>@RunWith(AndroidJUnit4.class)public class ExampleInstrumentedTest {    @Rule    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(            MainActivity.class);    @Test    public void useAppContext() throws Exception {        // Context of the app under test.        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),                closeSoftKeyboard());        onView(withId(R.id.btn)).perform(click());    }}</code></pre><p>其中**onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。</p><p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="noopener">更多操作方式-1</a><br><a href="http://blog.csdn.net/eclipsexys/article/details/45622813" target="_blank" rel="noopener">更多操作方式-2</a></p><h4>标签解析</h4><pre><code>@Rule: 应用于成员变量@ClassRule: 应用于测试类中的静态变量两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。@RunWith（AndroidJUnit4.class）：  用于修改测试运行器</code></pre><h3>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。</code></pre><p>Android自动化测试</p><p>enter image description here</p><p>Android自动化测试摘要Monkey测试简介使用方式效果展示更多参数介绍可能会遇到的问题单元测试简介使用方式Junit标签解析Mockito使用方式UI测试简介使用方式标签解析总结摘要</p><p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。Monkey测试</p><p>简介</p><p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p><p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：</p><pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         </code></pre><p>效果展示</p><p>部分输出数据如下所示：</p><p>输出数据</p><p>更多参数介绍</p><p>点击查看</p><p>可能会遇到的问题</p><p>（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p><p>单元测试</p><p>简介</p><p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。使用方式</p><p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p><p>dependencies {testCompile 'junit:junit:4.12'}而后在test文件下写单元测试类</p><p>enter image description here</p><p>被测试类如下</p><p>public class Calculator {public static int add(int a, int b) {return a + b;}}单元测试类如下</p><p>public class ExampleUnitTest {@Testpublic void addition_isCorrect() throws Exception {assertEquals(4, Calculator.add(2,2));}}最后运行单元测试类，结果如下：</p><p>enter image description here</p><p>Junit标签解析</p><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p><p>@Test： 将方法（函数）标记为测试用例@Before： 每一个使用@Test标记的方法运行之前都要运行一次@After： 每一个使用@Test标记的方法运行之后都要运行一次@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次以如下代码为例：</p><p>public class ExampleUnitTest {</p><pre><code>@Testpublic void addition_isCorrect() throws Exception {    System.out.println(&quot;@Test&quot;);}@Testpublic void addition_isErr() throws Exception {    System.out.println(&quot;@Test&quot;);}@Beforepublic void before() throws Exception {    System.out.println(&quot;@Before&quot;);}@Afterpublic void after() throws Exception {    System.out.println(&quot;@After&quot;);}@AfterClasspublic static void afterClass() throws Exception {    System.out.println(&quot;@AfterClass&quot;);}@BeforeClasspublic static void beforeClass() throws Exception {    System.out.println(&quot;@BeforeClass&quot;);}</code></pre><p>}相应的执行顺序如下：</p><p>enter image description here</p><p>Mockito使用方式</p><p>简介：</p><p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。先体验以下Mockito的使用：</p><p>1.添加依赖</p><p>testCompile 'org.mockito:mockito-core:2.8.47'2.被依赖类</p><p>public interface IMathUtils {public int abs(int num); // 求绝对值}3.依赖类</p><p>@RunWith(MockitoJUnitRunner.class)public class MockTest {@MockIMathUtils mathUtils;</p><pre><code>@Testpublic void mockTest() {    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1    int abs = mathUtils.abs(-1); // 输出结果 1    Assert.assertEquals(abs, 1);// 测试通过}</code></pre><p>}可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p><p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p><p>上述的依赖类也可以使用如下方式来写：</p><p>public class MockTest {</p><pre><code>@MockIMathUtils iMathUtils ; @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @Testpublic void mockTest()  {    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1    int abs = mathUtils.abs(-1); // 输出结果 1    Assert.assertEquals(abs, 1);// 测试通过}</code></pre><p>}其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p><p>Mock配置</p><p>Mock有多种配置方式，如下所示：</p><p>@Testpublic void test1()  {//  创建 mockMyClass test = Mockito.mock(MyClass.class);</p><pre><code>// 自定义 getUniqueId() 的返回值when(test.getUniqueId()).thenReturn(43);// 在测试中使用mock对象assertEquals(test.getUniqueId(), 43);</code></pre><p>}</p><p>// 返回多个值@Testpublic void testMoreThanOneReturnValue()  {Iterator i= mock(Iterator.class);when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);String result=i.next()+&quot; &quot;+i.next();// 断言assertEquals(&quot;Mockito rocks&quot;, result);}</p><p>// 如何根据输入来返回值@Testpublic void testReturnValueDependentOnMethodParameter()  {Comparable c= mock(Comparable.class);when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);// 断言assertEquals(1,c.compareTo(&quot;Mockito&quot;));}</p><p>// 如何让返回值不依赖于输入@Testpublic void testReturnValueInDependentOnMethodParameter()  {Comparable c= mock(Comparable.class);when(c.compareTo(anyInt())).thenReturn(-1);// 断言assertEquals(-1 ,c.compareTo(9));}</p><p>// 根据参数类型来返回值@Testpublic void testReturnValueInDependentOnMethodParameter()  {Comparable c= mock(Comparable.class);when(c.compareTo(isA(Todo.class))).thenReturn(0);// 断言Todo todo = new Todo(5);assertEquals(todo ,c.compareTo(new Todo(1)));}更多配置可以看下这个网站 点击链接</p><p>UI测试</p><p>简介</p><p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。使用方式</p><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p><p>testCompile 'com.android.support.test.espresso:espresso-core:2.2.2'testCompile 'com.android.support.test:runner:0.4.1'2.在androidTest目录下创建测试类</p><p>enter image description here</p><p>3.被测试类（即activity之类的展示界面）MainActivity.class</p><p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p><pre><code>private EditText mEt;private TextView mTv;private Button mBtn;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    mEt = (EditText) findViewById(R.id.et);    mTv = (TextView) findViewById(R.id.tv);    mBtn = (Button) findViewById(R.id.btn);    mBtn.setOnClickListener(this);}@Overridepublic void onClick(View v) {    mTv.setText(mEt.getText().toString());}</code></pre><p>}activity_main.xml</p><p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;</p><p>&lt;TextViewandroid:id=&quot;@+id/tv&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;wrap_content&quot;android:layout_marginTop=&quot;15dp&quot;android:padding=&quot;10dp&quot;android:text=&quot;helo&quot; /&gt;</p><p>&lt;EditTextandroid:id=&quot;@+id/et&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;40dp&quot;android:layout_alignParentLeft=&quot;true&quot;android:layout_alignParentStart=&quot;true&quot;android:layout_alignParentTop=&quot;true&quot;android:layout_marginTop=&quot;75dp&quot; /&gt;</p><p>&lt;Buttonandroid:id=&quot;@+id/btn&quot;android:layout_width=&quot;80dp&quot;android:layout_height=&quot;wrap_content&quot;android:layout_below=&quot;@+id/et&quot;android:layout_centerHorizontal=&quot;true&quot;android:layout_marginTop=&quot;49dp&quot;android:text=&quot;sure&quot; /&gt;&lt;/RelativeLayout&gt;测试类ExampleInstrumentedTest.class</p><p>@RunWith(AndroidJUnit4.class)public class ExampleInstrumentedTest {@Rulepublic ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(MainActivity.class);</p><pre><code>@Testpublic void useAppContext() throws Exception {    // Context of the app under test.    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),            closeSoftKeyboard());    onView(withId(R.id.btn)).perform(click());}</code></pre><p>}其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p><p>更多操作方式-1更多操作方式-2</p><p>标签解析</p><p>@Rule: 应用于成员变量@ClassRule: 应用于测试类中的静态变量两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p><p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器总结</p><p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。7539qqq2830退出账号当前文档恢复至上次同步状态删除文档导出...预览文档分享链接系统设置使用说明快捷帮助常见问题关于</p><p>搜索文件杂物 Android自动化测试杂物 SwipeToLoadLayout检查Evernote中的笔记版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;摘要&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Androi
      
    
    </summary>
    
      <category term="Android基础学习" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>compileSdkVersion, minSdkVersion， targetSdkVersion的关系</title>
    <link href="http://yoursite.com/2016/06/01/compileSdkVersion,%20minSdkVersion%EF%BC%8C%20targetSdkVersion%E8%BF%99%E4%B8%89%E5%85%84%E5%BC%9F/"/>
    <id>http://yoursite.com/2016/06/01/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟/</id>
    <published>2016-06-01T15:47:44.000Z</published>
    <updated>2018-05-23T14:49:55.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20161130141617130" alt="这里写图片描述"></p><h2><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2><p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p><p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p><h2><strong>compileSdkVersion</strong></h2><p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p><p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）</p><p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p><p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p><h2><strong>minSdkVersion</strong></h2><p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p><p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p><p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p><p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p><p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p><h2><strong>targetSdkVersion</strong></h2><p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p><p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p><p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p><p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p><h2><strong>Gradle and SDK versions</strong></h2><p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 23</span><br><span class="line">  buildToolsVersion “23.0.1”</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class="line">    minSdkVersion 7</span><br><span class="line">    targetSdkVersion 23</span><br><span class="line">    versionCode 1</span><br><span class="line">    versionName “1.0”</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href="http://blog.csdn.net/qqq2830/article/details/53405699" target="_blank" rel="noopener">链接地址</a>。</p><p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p><p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p><h2><strong>总的来说三者的关系</strong></h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure></p><p><strong>理想化来说应该是这样：</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion (lowest possible) &lt;= </span><br><span class="line">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure></p><p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p><p>期待您的加入 <a href="https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Google+ post</a> 和<a href="https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener"> Android Development Patterns Collection</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161130141617130&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;选择你自己的 compileSdkVersion, minSdkVersion, and targetS
      
    
    </summary>
    
      <category term="Android基础学习" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2全面解析</title>
    <link href="http://yoursite.com/2016/06/01/Dagger2/"/>
    <id>http://yoursite.com/2016/06/01/Dagger2/</id>
    <published>2016-06-01T15:47:44.000Z</published>
    <updated>2018-05-23T14:49:55.413Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://op0dvu7tu.bkt.clouddn.com/timg.jpg" alt="enter image description here"></p><h3>Dagger2的好处</h3><ul><li>依赖的注入和配置独立于组件之外。</li><li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li><li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li></ul><h3>相关标签</h3><p><strong>@Inject、@Module、@Provide、@Component</strong></p><ul><li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p></li><li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p></li><li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p></li><li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p></li></ul><h3>标签使用方式</h3><p><strong>1.@Inject</strong></p><pre><code>public class User {      ....      ....      //在被依赖类中使用@Inject标记该类的构造方法    @Inject      public User() {      }        ....      ....    }  </code></pre><hr><pre><code>public class MainActivity extends AppCompatActivity {        //在依赖类中使用@Inject来注入被依赖类实例    @Inject      User user;      @Inject      User user2;      private TextView tv;      private TextView tv2;        @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(R.layout.activity_main);          //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值        DaggerActivityComponent.builder().build().inject(this);          tv = ((TextView) findViewById(R.id.tv));          tv2 = ((TextView) findViewById(R.id.tv2));          tv.setText(user.toString());          tv2.setText(user2.toString());      }  } </code></pre><p><strong>2.@Component</strong></p><pre><code>@Component  public interface ActivityComponent {      void inject(MainActivity activity);  }  </code></pre><p><strong>3.@Provider &amp; @Module</strong></p><pre><code>@Module  public class UserModule {      @Provides    User providesUser() {          return new User();      }  }  </code></pre><h3>注入方式</h3><ul><li>构造方法注入：在类的构造方法前面注释@Inject</li><li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li><li>函数方法注入：在函数前面注释@Inject</li></ul><h3>不同类的关系</h3><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png" alt="enter image description here"></p><h3>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png" alt="enter image description here"></p><p><strong>生成文件</strong><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png" alt="enter image description here"></p><p><strong>各文件对应关系</strong><img src="http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="enter image description here"></p><h3>注入路径</h3><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png" alt="enter image description here"></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png" alt="enter image description here"></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png" alt="enter image description here"></p><h3>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png" alt="enter image description here"></p><p><strong>用户自己写的</strong></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png" alt="enter image description here"></p><p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p><h4>各标签的意义</h4><p><strong>@Retention</strong></p><p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p><p><strong>@Documented</strong></p><p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用</p><p><strong>@Scope</strong></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png" alt="enter image description here"></p><h3>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png" alt="enter image description here"></p><p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png" alt="enter image description here"></p><h3>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p><p>两个@Qualifier</p><pre><code>@Qualifierpublic @interface ThemeNight {}@Qualifierpublic @interface ThemeDay {}</code></pre><hr><pre><code>@Modulepublic class ThemeModule {    @Provides    @ThemeDay    Theme provideDayTheme() {        return new Theme(&quot;day&quot;);    }    @Provides    @ThemeNight    Theme provideNightTheme() {        return new Theme(&quot;night&quot;);    }}</code></pre><hr><pre><code>@Componentpublic interface ThemeComponent{    void inject(ThemeTest themeTest);}</code></pre><hr><pre><code>public class ThemeTest {    @Inject    @ThemeDay    Theme dayTheme;    @Inject    @ThemeNight    Theme nightTheme;    public static void main(String[] arg) {        ThemeTest themeTest = new ThemeTest();        DaggerThemeComponent.create().inject(themeTest);        System.out.println(themeTest.dayTheme.themeName);        System.out.println(themeTest.nightTheme.themeName);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://op0dvu7tu.bkt.clouddn.com/timg.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Dagger2的好处&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;依赖的注入和配置独立于组件之外
      
    
    </summary>
    
      <category term="Android基础学习" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="三方框架" scheme="http://yoursite.com/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
