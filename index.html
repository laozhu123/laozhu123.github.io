<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="来自贫穷小山村，但我想回去">
    

    <!--Author-->
    
        <meta name="author" content="塑料葫芦娃">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="生死看淡，不服就干"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="来自贫穷小山村，但我想回去" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="生死看淡，不服就干"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>生死看淡，不服就干</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">生死看淡，不服就干</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/09/一些特殊类/">
                一些特殊的类
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android源码学习/">Android源码学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3>一些特殊的类</h3>
<h4>FutureTask</h4>
<p>该类继承自RunnableFuture，所以有Runnable和Future的特性，有run和get方法，可封装Runnable和Callable，而后可以用Executor的submit方法运行，可以一方面在异步线程中进行耗时操作的计算，然后过一段时间后再主线程中使用get方法获取相应的结果。但是get方法使用的时候回阻塞线程。</p>
<h4>IntentService</h4>
<p>用于进行耗时操作的Service，操作完成后自动停止。</p>
<p>是Service的子类，通过startService（intent）来传递请求，进行异步耗时操作。</p>
<p>使用方式：重写onHandleIntent(Intent)方法，接受请求，开启一个工作线程，单线程操作，估计有抢占机制，在8.0推荐使用JobIntentService类来代替，通过jobs来替换services</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">		HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">		thread.start();</span><br><span class="line">		</span><br><span class="line">		mServiceLooper = thread.getLooper();</span><br><span class="line">		mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>/**
* Unless you provide binding for your service, you don't need to implement this
* method, because the default implementation returns null.
* @see android.app.Service#onBind
*/
@Override
@Nullable
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>onstartCommand -&gt; onstart -&gt; sendMessage -&gt; handleMessage -&gt; onHandleIntent</p>
<blockquote>
<p>/**
* You should not override this method for your IntentService. Instead,
* override {@link #onHandleIntent}, which the system calls when the IntentService
* receives a start request.
* @see android.app.Service#onStartCommand
*/</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">     onStart(intent, startId);</span><br><span class="line">     return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>调用IntentService中的onHandleIntent方法，故而我们只需重写intentService中的onHandleIntent方法就可以了。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">        public ServiceHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>/**
* This method is invoked on the worker thread with a request to process.
* Only one Intent is processed at a time, but the processing happens on a
* worker thread that runs independently from other application logic.
* So, if this code takes a long time, it will hold up other requests to
* the same IntentService, but it will not hold up anything else.
* When all requests have been handled, the IntentService stops itself,
* so you should not call {@link #stopSelf}.
*
* @param intent The value passed to {@link
*               android.content.Context#startService(Intent)}.
*               This may be null if the service is being restarted after
*               its process has gone away; see
*               {@link android.app.Service#onStartCommand}
*               for details.
*/</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">   protected abstract void onHandleIntent(@Nullable Intent intent);</span><br></pre></td></tr></table></figure></p>
<h4>HandlerThread</h4>
<blockquote>
<p>/**</p>
</blockquote>
<ul>
<li>Handy class for starting a new thread that has a looper. The looper can then be</li>
<li>used to create handler classes. Note that start() must still be called.
*/</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果想在启动Looper之前做一些操作的话，可以重写下面这个方法</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Call back method that can be explicitly overridden if needed to execute some</span><br><span class="line">     * setup before Looper loops.</span><br><span class="line">     */</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/09/OkHttp/">
                OkHttp
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android三方库/">Android三方库</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3>一.基础内容</h3>
<h4>1.请求体</h4>
<p>访问协议, 响应码, 描述信息, 响应头, 响应体</p>
<h4>2.使用代码</h4>
<p>1.get同步和异步方式</p>
<pre><code>Request request = new Request.Builder()
    .url(&quot;http://publicobject.com/helloworld.txt&quot;)
    .build();

Response response = client.newCall(request).execute();

client.newCall(request).enqueue(new Callback() {
  @Override public void onFailure(Request request, Throwable throwable) {
    
  }

  @Override public void onResponse(Response response) throws IOException {
    
  }
});
</code></pre>
<p>2.post方式提交string</p>
<pre><code>String postBody = &quot;&quot;
    + &quot;Releases\n&quot;
    + &quot;--------\n&quot;
    + &quot;\n&quot;
    + &quot; * _1.0_ May 6, 2013\n&quot;
    + &quot; * _1.1_ June 15, 2013\n&quot;
    + &quot; * _1.2_ August 11, 2013\n&quot;;

Request request = new Request.Builder()
    .url(&quot;https://api.github.com/markdown/raw&quot;)
    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
    .build();

Response response = client.newCall(request).execute();
</code></pre>
<p>3.post方式提交流</p>
<p>以流的方式POST提交请求体. 请求体的内容由流写入产生. 这个例子是流直接写入Okio的BufferedSink. 你的程序可能会使用OutputStream, 你可以使用BufferedSink.outputStream()来获取. OkHttp的底层对流和字节的操作都是基于Okio库, Okio库也是Square开发的另一个IO库, 填补I/O和NIO的空缺, 目的是提供简单便于使用的接口来操作IO.</p>
<pre><code>RequestBody requestBody = new RequestBody() {
  @Override public MediaType contentType() {
    return MEDIA_TYPE_MARKDOWN;
  }

  @Override public void writeTo(BufferedSink sink) throws IOException {
    sink.writeUtf8(&quot;Numbers\n&quot;);
    sink.writeUtf8(&quot;-------\n&quot;);
    for (int i = 2; i &lt;= 997; i++) {
      sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));
    }
  }

  private String factor(int n) {
    for (int i = 2; i &lt; n; i++) {
      int x = n / i;
      if (x * i == n) return factor(x) + &quot; × &quot; + i;
    }
    return Integer.toString(n);
  }
};
</code></pre>
<p>4.Post方式提交文件</p>
<pre><code>File file = new File(&quot;README.md&quot;);
RequestBody formBody=RequestBody.create(MEDIA_TYPE_MARKDOWN, file)
</code></pre>
<p>5.Post方式提交表单</p>
<pre><code>RequestBody formBody = new FormBody.Builder()
    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)
    .build();
</code></pre>
<p>6.Post方式提交分块请求</p>
<p>MultipartBody.Builder可以构建复杂的请求体, 与HTML文件上传形式兼容. 多块请求体中每块请求都是一个请求体, 可以定义自己的请求头. 这些请求头可以用来描述这块请求, 例如它的Content-Disposition. 如果Content-Length和Content-Type可用的话, 他们会被自动添加到请求头中.</p>
<pre><code>RequestBody requestBody = new MultipartBody.Builder()
    .setType(MultipartBody.FORM)
    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)
    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,
        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))
    .build();

Request request = new Request.Builder()
    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)
    .url(&quot;https://api.imgur.com/3/image&quot;)
    .post(requestBody)
    .build();

Response response = client.newCall(request).execute();
</code></pre>
<p>7.设置请求头</p>
<pre><code>Request request = new Request.Builder()
    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)
    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)
    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)
    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)
    .build();
</code></pre>
<p>8.使用Gson来解析JSON响应</p>
<pre><code>private final Gson gson = new Gson();
Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
</code></pre>
<p>9.响应缓存</p>
<p>大多数程序只需要调用一次new OkHttp(), 在第一次调用时配置好缓存, 然后其他地方只需要调用这个实例就可以了. 否则两个缓存示例互相干扰, 破坏响应缓存, 而且有可能会导致程序崩溃.
响应缓存使用HTTP头作为配置. 你可以在请求头中添加Cache-Control: max-stale=3600 , OkHttp缓存会支持. 你的服务通过响应头确定响应缓存多长时间, 例如使用Cache-Control: max-age=9600.</p>
<pre><code>int cacheSize = 10 * 1024 * 1024; // 10 MiB
Cache cache = new Cache(cacheDirectory, cacheSize);

client = new OkHttpClient();
client.setCache(cache);
</code></pre>
<p>10.Force a Network Response or Cache</p>
<pre><code>connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);
InputStream cached = connection.getInputStream();
</code></pre>
<p>11.取消一个Call</p>
<p>使用Call.cancel()可以立即停止掉一个正在执行的call. 如果一个线程正在写请求或者读响应, 将会引发IOException. 当call没有必要的时候, 使用这个api可以节约网络资源. 例如当用户离开一个应用时, 不管同步还是异步的call都可以取消.
你可以通过tags来同时取消多个请求. 当你构建一请求时, 使用RequestBuilder.tag(tag)来分配一个标签, 之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call.</p>
<p>12.超时</p>
<p>没有响应时使用超时结束call. 没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西. OkHttp支持连接超时, 读取超时和写入超时.</p>
<pre><code>client = new OkHttpClient.Builder()
    .connectTimeout(10, TimeUnit.SECONDS)
    .writeTimeout(10, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .build();
</code></pre>
<p>13.每个Call的设置不同</p>
<pre><code>private final OkHttpClient client = new OkHttpClient();

public void run() throws Exception {
	Request request = new Request.Builder()
      .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.
      .build();

    try {
      // Copy to customize OkHttp for this request.
      OkHttpClient copy = client.newBuilder()
          .readTimeout(500, TimeUnit.MILLISECONDS)
          .build();

      Response response = copy.newCall(request).execute();
      System.out.println(&quot;Response 1 succeeded: &quot; + response);
    } catch (IOException e) {
      System.out.println(&quot;Response 1 failed: &quot; + e);
    }

    try {
      // Copy to customize OkHttp for this request.
      OkHttpClient copy = client.newBuilder()
          .readTimeout(3000, TimeUnit.MILLISECONDS)
          .build();

      Response response = copy.newCall(request).execute();
      System.out.println(&quot;Response 2 succeeded: &quot; + response);
    } catch (IOException e) {
      System.out.println(&quot;Response 2 failed: &quot; + e);
    }
}
</code></pre>
<h3>二.源码解析</h3>
<p>1.OkHttpClient的内容</p>
<pre><code>public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
	public OkHttpClient() {
       this(new Builder());
	}
	OkHttpClient(Builder builder) {
    this.dispatcher = builder.dispatcher;
    this.proxy = builder.proxy;
    this.protocols = builder.protocols;
    this.connectionSpecs = builder.connectionSpecs;
    this.interceptors = Util.immutableList(builder.interceptors);
    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
    this.eventListenerFactory = builder.eventListenerFactory;
    this.proxySelector = builder.proxySelector;
    this.cookieJar = builder.cookieJar;
    this.cache = builder.cache;
    this.internalCache = builder.internalCache;
    this.socketFactory = builder.socketFactory;

    boolean isTLS = false;
    ......

    this.hostnameVerifier = builder.hostnameVerifier;
    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
        certificateChainCleaner);
    this.proxyAuthenticator = builder.proxyAuthenticator;
    this.authenticator = builder.authenticator;
    this.connectionPool = builder.connectionPool;
    this.dns = builder.dns;
    this.followSslRedirects = builder.followSslRedirects;
    this.followRedirects = builder.followRedirects;
    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
    this.connectTimeout = builder.connectTimeout;
    this.readTimeout = builder.readTimeout;
    this.writeTimeout = builder.writeTimeout;
    this.pingInterval = builder.pingInterval;
  }
}
</code></pre>
<p>2.Request内容</p>
<pre><code>Request request = new Request.Builder().url(&quot;url&quot;).build();


public final class Request {
    public Builder() {
      this.method = &quot;GET&quot;;
      this.headers = new Headers.Builder();
    }
    public Builder url(String url) {
      ......

      // Silently replace web socket URLs with HTTP URLs.
      if (url.regionMatches(true, 0, &quot;ws:&quot;, 0, 3)) {
        url = &quot;http:&quot; + url.substring(3);
      } else if (url.regionMatches(true, 0, &quot;wss:&quot;, 0, 4)) {
        url = &quot;https:&quot; + url.substring(4);
      }

      HttpUrl parsed = HttpUrl.parse(url);
      ......
      return url(parsed);
    }
    public Request build() {
      ......
      return new Request(this);
    }
}
</code></pre>
<p>3.newCall( Request)</p>
<pre><code>public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
   @Override 
   public Call newCall(Request request) {
    return new RealCall(this, request, false /* for web socket */);
   }
}
</code></pre>
<p>RealCall实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p>
<p>4.异步请求</p>
<pre><code>final class RealCall implements Call {
   @Override 
   public void enqueue(Callback responseCallback) {
   synchronized (this) {
   if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
   }
    captureCallStackTrace();
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
  }
}
</code></pre>
<p>由以上源码得知：</p>
<p>1） 检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 call#clone 方法进行克隆。</p>
<p>2）利用 client.dispatcher().enqueue(this) 来进行实际执行，dispatcher 是刚才看到的 OkHttpClient.Builder 的成员之一</p>
<p>3）AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  @Override </span><br><span class="line">  public final void run() &#123;</span><br><span class="line">   ......</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而后在其execute（）方法中使用</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          // Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          eventListener.callFailed(RealCall.this, e);</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来观察getResponseWithInterceptorChain（），该方法就是使用拦截器对请求进行处理</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">        originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中CallServerInterceptor是最后一个Interceptor，用于进行网络请求，其他的是可以对头部进行一些处理</p>
<p>查看chain.proceed(request)方法</p>
<p>AsyncCall实现了execute方法，首先是调用getResponseWithInterceptorChain()方法获取响应，然后获取成功后，就调用回调的onReponse方法，如果失败，就调用回调的onFailure方法。最后，调用Dispatcher的finished方法。</p>
<p>关键代码：</p>
<p>responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));</p>
<p>和</p>
<p>responseCallback.onResponse(RealCall.this, response);</p>
<p>走完这两句代码会进行回调到刚刚我们初始化Okhttp的地方</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/08/Android中当item数量超过一定大小RecyclerView高度固定/">
                Android中当item数量超过一定大小RecyclerView高度固定
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-08</span>
            
            
            
                <span class="category">
                    <a href="/categories/java基础学习/">java基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3>Android中当item数量超过一定大小时，将RecyclerView高度固定</h3>
<h4>方法1</h4>
<blockquote>
<p>直接通过LayoutParams来设定相应高度</p>
</blockquote>
<pre><code>ViewGroup.LayoutParams lp = rv.getLayoutParams();
if (list.size() &gt; 4) {
    lp.height = DensityUtil.dip2px(mContext,32 * 4);
} else {
    lp.height = DensityUtil.dip2px(mContext,34 * list.size());
}
rv.setLayoutParams(lp);
</code></pre>
<p>该方法只适用于item高度固定，在本例中使用34dp来设置相应的item高度，故而可以通过乘上相应的item数来计算RecyclerView的高度。</p>
<h4>方法2</h4>
<blockquote>
<p>重写LayoutManger的onMeasure方法，这种方式可以获取到各个item的不同高度，从而可以设置变动的高度。</p>
</blockquote>
<p><strong>在使用这种方式时，有一点需要注意的是，不要将RecyclerView的android:layout_height属性设置为wrap_content，不然是不会成功的。</strong></p>
<pre><code>rv.setLayoutManager(new LinearLayoutManager(mContext) {
                @Override
                public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) {
                    int count = state.getItemCount();
                    if (count &gt; 0) {
                        int realHeight = 0;
                        int realWidth = 0;
                        for(int i = 0;i &lt; count; i++){
	                        View view = recycler.getViewForPosition(0);
	                        if (view != null) {
                                measureChild(view, widthSpec, heightSpec);
                                int measuredWidth = View.MeasureSpec.getSize(widthSpec);
                                int measuredHeight = view.getMeasuredHeight();    
                                realWidth = realWidth &gt; measuredWidth ? realWidth : measureWidth;
                                realHeight += measureHeight;            
                            }
                            setMeasuredDimension(realWidth, realHeight); 
                        }                           
                    } else {
                    super.onMeasure(recycler, state, widthSpec, heightSpec);
               }
           }
        });
</code></pre>
<p>方法中的recycler是一个item的循环使用器，起到对item管理的作用。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/08/Java线程池的4中拒绝策略/">
                java线程池的4种拒绝模式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-08</span>
            
            
            
                <span class="category">
                    <a href="/categories/java基础学习/">java基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3>简介</h3>
<p>在线程池的使用中，当任务数量超出之前设定的线程池大小（既：核心线程数+等待队列大小），系统需要采取相应策略来应对新进来的任务。当前java线程池有4种不同的策略来应对这种情况。</p>
<h3>拒绝策略</h3>
<h4>1.AbortPolicy</h4>
<blockquote>
<ul>
<li>In the default {@link ThreadPoolExecutor.AbortPolicy}, the</li>
</ul>
</blockquote>
<ul>
<li>handler throws a runtime {@link RejectedExecutionException} upon</li>
<li>rejection.</li>
</ul>
<p>通过该段注释可以知道，该策略是线程池的<strong>默认策略</strong>。该策略的机制是，通过抛出一个RejectedExecutionException异常来拒绝新添加的任务。</p>
<pre><code>/**
 * A handler for rejected tasks that throws a
 * {@code RejectedExecutionException}.
 */
public static class AbortPolicy implements RejectedExecutionHandler {
    /**
     * Creates an {@code AbortPolicy}.
     */
    public AbortPolicy() { }

    /**
     * Always throws RejectedExecutionException.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     * @throws RejectedExecutionException always
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                             &quot; rejected from &quot; +
                                             e.toString());
    }
}
</code></pre>
<p>只是简单的抛出一个RejectedExecutionException异常，异常中的信息是任务名和拒绝它的线程池。</p>
<h4>2.CallerRunsPolicy</h4>
<blockquote>
<ul>
<li>In {@link ThreadPoolExecutor.CallerRunsPolicy}, the thread</li>
</ul>
</blockquote>
<ul>
<li>that invokes {@code execute} itself runs the task. This provides a</li>
<li>simple feedback control mechanism that will slow down the rate that</li>
<li>new tasks are submitted.</li>
</ul>
<p>该策略直接使用当前线程来运行任务的run方法，这种方式会降低新任务的执行率。看下相应的代码：</p>
<pre><code>public static class CallerRunsPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code CallerRunsPolicy}.
     */
    public CallerRunsPolicy() { }

    /**
     * Executes task r in the caller's thread, unless the executor
     * has been shut down, in which case the task is discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}
</code></pre>
<p>当过多的新任务来时，回调用rejectedExecution方法，该方法直接在任务调用者（也就是执行executor.execute(r)）所在线程中执行任务的run方法。</p>
<h4>DiscardPolicy</h4>
<blockquote>
<ul>
<li>In {@link ThreadPoolExecutor.DiscardPolicy}, a task that</li>
</ul>
</blockquote>
<ul>
<li>cannot be executed is simply dropped.</li>
</ul>
<p>通过翻译可知，该策略只是简单的将新任务抛弃，并不会抛出异常。</p>
<pre><code>/**
 * A handler for rejected tasks that silently discards the
 * rejected task.
 */
public static class DiscardPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code DiscardPolicy}.
     */
    public DiscardPolicy() { }

    /**
     * Does nothing, which has the effect of discarding task r.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}
</code></pre>
<p>rejectedExecution方法是空的，不做任何处理。</p>
<h4>DiscardOldestPolicy</h4>
<blockquote>
<ul>
<li>In {@link ThreadPoolExecutor.DiscardOldestPolicy}, if the</li>
</ul>
</blockquote>
<ul>
<li>executor is not shut down, the task at the head of the work queue</li>
<li>is dropped, and then execution is retried (which can fail again,</li>
<li>causing this to be repeated.)</li>
</ul>
<p>该策略会将等待队列中等待最久的一个出队列，而后再次执行execute(r)方法，但是执行execute(r)方法时会有再次失败的可能，因为这里的出队列和进队列不是原子性的，在多线程环境下还是会存在别的线程先执行了execute(r)方法，将相应的任务push进等待队列中。</p>
<pre><code>public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code DiscardOldestPolicy} for the given executor.
     */
    public DiscardOldestPolicy() { }

    /**
     * Obtains and ignores the next task that the executor
     * would otherwise execute, if one is immediately available,
     * and then retries execution of task r, unless the executor
     * is shut down, in which case task r is instead discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}
</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/08/android混淆中需要keep的部分/">
                proguard
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-08</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android基础学习/">Android基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h4>简介</h4>
<blockquote>
<p>Proguard是一个集文件压缩,优化,混淆和校验等功能的工具
它检测并删除无用的类,变量,方法和属性
它优化字节码并删除无用的指令.
它通过将类名,变量名和方法名重命名为无意义的名称实现混淆效果.
最后它还校验处理后的代码</p>
</blockquote>
<p>保留某个包下面的类以及子包</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class com.droidyue.com.widget.**</span><br></pre></td></tr></table></figure></p>
<p>保留所有类中使用otto的public方法</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Otto</span><br><span class="line">-keepclassmembers class ** &#123;</span><br><span class="line">    @com.squareup.otto.Subscribe public *;</span><br><span class="line">    @com.squareup.otto.Produce public *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保留Contants类的BOOK_NAME属性</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers class com.example.admin.proguardsample.Constants &#123;</span><br><span class="line">     public static java.lang.String BOOK_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>-dontwarn</h3>
<blockquote>
<p>dontwarn是一个和keep可以说是形影不离,尤其是处理引入的library时.</p>
</blockquote>
<p>引入的library可能存在一些无法找到的引用和其他问题,在build时可能会发出警告,如果我们不进行处理,通常会导致build中止.因此为了保证build继续,我们需要使用dontwarn处理这些我们无法解决的library的警告.</p>
<p>比如关闭Twitter sdk的警告,我们可以这样做</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn com.twitter.sdk.**</span><br></pre></td></tr></table></figure></p>
<h3>哪些不应该混淆</h3>
<h4>反射中使用的元素</h4>
<blockquote>
<p>如果一些被混淆使用的元素(属性,方法,类,包名等)进行了混淆,可能会出现问题,如NoSuchFiledException或者NoSuchMethodException等.</p>
<p>想要验证,我们需要看一看混淆的映射文件,文件名为mapping.txt,该文件保存着混淆前后的映射关系.</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.example.admin.proguardsample.Constants -&gt; com.example.admin.proguardsample.a:</span><br><span class="line">    java.lang.String BOOK_NAME -&gt; a</span><br><span class="line">    void &lt;init&gt;() -&gt; &lt;init&gt;</span><br><span class="line">    void &lt;clinit&gt;() -&gt; &lt;clinit&gt;</span><br><span class="line">com.example.admin.proguardsample.MainActivity -&gt; com.example.admin.proguardsample.MainActivity:</span><br><span class="line">    void &lt;init&gt;() -&gt; &lt;init&gt;</span><br><span class="line">    void onCreate(android.os.Bundle) -&gt; onCreate</span><br></pre></td></tr></table></figure></p>
<h4>GSON的序列化与反序列化</h4>
<blockquote>
<p>因为反序列化创建对象本质还是利用反射,会根据json字符串的key作为属性名称,value则对应属性值.</p>
</blockquote>
<p><strong>序列化</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item toSerializeItem = new Item();</span><br><span class="line">toSerializeItem.id = 2;</span><br><span class="line">toSerializeItem.name = &quot;Apple&quot;;</span><br><span class="line">String serializedText = gson.toJson(toSerializeItem);</span><br><span class="line">Log.i(LOGTAG, &quot;testGson serializedText=&quot; + serializedText);</span><br></pre></td></tr></table></figure></p>
<p><strong>反序列化</strong></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new Gson();</span><br><span class="line">Item item = gson.fromJson(&quot;&#123;\&quot;id\&quot;:1, \&quot;name\&quot;:\&quot;Orange\&quot;&#125;&quot;, Item.class);</span><br><span class="line">Log.i(LOGTAG, &quot;testGson item.id=&quot; + item.id + &quot;;item.name=&quot; + item.name);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如何解决</li>
</ul>
<blockquote>
<p>1.将序列化和反序列化的类排除混淆
2.使用@SerializedName注解字段</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Item &#123;</span><br><span class="line">    @SerializedName(&quot;name&quot;)</span><br><span class="line">    public String name;</span><br><span class="line">    @SerializedName(&quot;id&quot;)</span><br><span class="line">    public int id;</span><br></pre></td></tr></table></figure></p>
<h4>枚举也不要混淆</h4>
<p>枚举使用起来很简单,如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Day &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>默认的Proguard配置已经处理了枚举相关的keep操作.</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enum文件编译后产生的class文件如下：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  proguardsample javap  Day</span><br><span class="line">Warning: Binary file Day contains com.example.admin.proguardsample.Day</span><br><span class="line">Compiled from &quot;Day.java&quot;</span><br><span class="line">public final class com.example.admin.proguardsample.Day extends java.lang.Enum&lt;com.example.admin.proguardsample.Day&gt; &#123;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day MONDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day TUESDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day WEDNESDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day THURSDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day FRIDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day SATURDAY;</span><br><span class="line">  public static final com.example.admin.proguardsample.Day SUNDAY;</span><br><span class="line">  public static com.example.admin.proguardsample.Day[] values();</span><br><span class="line">  public static com.example.admin.proguardsample.Day valueOf(java.lang.String);</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>四大组件不建议混淆</h4>
<blockquote>
<p>四大组件声明必须在manifest中注册,如果混淆后类名更改,而混淆后的类名没有在manifest注册,是不符合Android组件注册机制的.
外部程序可能使用组件的字符串类名,如果类名混淆,可能导致出现异常</p>
</blockquote>
<h4>注解不能混淆</h4>
<blockquote>
<p>注解在Android平台中使用的越来越多,常用的有ButterKnife和Otto.很多场景下注解被用作在运行时反射确定一些元素的特征.</p>
</blockquote>
<blockquote>
<p>为了保证注解正常工作,我们不应该对注解进行混淆.Android工程默认的混淆配置已经包含了下面保留注解的配置</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure></p>
<h4>其他不该混淆的</h4>
<blockquote>
<p>jni调用的java方法
java的native方法
js调用java的方法
第三方库不建议混淆
其他和反射相关的一些情况</p>
</blockquote>
<p>stacktrace的恢复
Proguard混淆带来了很多好处,但是也会导致我们收集到的崩溃的stacktrace变得更加难以读懂,好在有补救的措施,这里就介绍一个工具,retrace,用来将混淆后的stacktrace还原成混淆之前的信息.</p>
<p>retrace脚本
Android 开发环境默认带着retrace脚本,一般情况下路径为./tools/proguard/bin/retrace.sh</p>
<p>mapping映射表
Proguard进行混淆之后,会生成一个映射表,文件名为mapping.txt,我们可以使用find工具在Project下查找</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name mapping.txt</span><br><span class="line">./app/build/outputs/mapping/release/mapping.txt</span><br></pre></td></tr></table></figure></p>
<p>一个崩溃stacktrace信息
一个原始的崩溃信息是这样的.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime(24006): Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">E/AndroidRuntime(24006):    at com.example.admin.proguardsample.a.a(Utils.java:10)</span><br><span class="line">E/AndroidRuntime(24006):    at com.example.admin.proguardsample.MainActivity.onCreate(MainActivity.java:22)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">E/AndroidRuntime(24006):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">E/AndroidRuntime(24006):    ... 10 more</span><br></pre></td></tr></table></figure></p>
<p>对上面的信息处理,去掉E/AndroidRuntime(24006):这些字符串retrace才能正常工作.得到的字符串是</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">at com.example.admin.proguardsample.a.a(Utils.java:10)</span><br><span class="line">at com.example.admin.proguardsample.MainActivity.onCreate(MainActivity.java:22)</span><br><span class="line">at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">... 10 more</span><br></pre></td></tr></table></figure></p>
<p>将上面的stacktrace保存成一个文本文件,比如名称为npe_stacktrace.txt.</p>
<p>开搞</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/proguard/bin/retrace.sh   /Users/admin/Downloads/ProguardSample/app/build/outputs/mapping/release/mapping.txt /tmp/npe_stacktrace.txt</span><br></pre></td></tr></table></figure></p>
<p>得到的易读的stacktrace是</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.graphics.Bitmap.getWidth()&apos; on a null object reference</span><br><span class="line">at com.example.admin.proguardsample.Utils.int getBitmapWidth(android.graphics.Bitmap)(Utils.java:10)</span><br><span class="line">at com.example.admin.proguardsample.MainActivity.void onCreate(android.os.Bundle)(MainActivity.java:22)</span><br><span class="line">at android.app.Activity.performCreate(Activity.java:6106)</span><br><span class="line">at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2566)</span><br><span class="line">... 10 more</span><br></pre></td></tr></table></figure></p>
<p>注意:为了更加容易和高效分析stacktrace,建议保留SourceFile和LineNumber属性</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题7/">
                Android面试7
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.fragment预加载
	通过使用setUserVisibleHint和getUserVisibleHint来完成</p>
<pre><code>public void setUserVisibleHint(boolean isVisibleToUser) {
    super.setUserVisibleHint(isVisibleToUser);
    if(isVisibleToUser &amp;&amp; viewIsVisible)
    	initData();

}
onCreate(){
    if (getUserVisibleHint() &amp;&amp; viewIsVisible){
        initData();
    }
}
</code></pre>
<p>2.Hashmap与HashTable的区别</p>
<pre><code>两者都是通过数组加链表的方式完成的，其中通过hashcode获取相应的hash值，而后通过该值寻找到相应链表的头，而后遍历链表获取到相应的entry对象

HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。我们一put方法为例，看一看代码的细节：

HashMap继承AbstractMap，HashTable继承dictionary，共同实现Serializable、Clonable，最后HashTable实现了Map，而AbstractMap实现了Map

Entry对象唯一表示一个键值对，有四个属性：
	-K key 键对象
	-V value 值对象
	-int hash 键对象的hash值
	-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部


也就是说HashTable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。我们知道当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀（具体证明，见这篇文章），所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。但另一方面我们又知道，在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。

HashTable： 
	11   2*n+1

HashMap：
	16或（2^n）   n*2


我们说HashTable是同步的，HashMap不是

使用new ConcurrentHashMap()，Collections.synchronizedMap(new Map)可以实现同步,其中ConcurrentHashMap使用segment将数据进行分段存储，同时为每段数据的操作进行加锁，所有速度比较快。而相对的Collections则是将相应的操作进行了synchronized加锁而已。
</code></pre>
<p>&lt;img src=&quot;http://img.blog.csdn.net/20150528211309106&quot; alt=&quot;这里写图片描述&quot; title=&quot;&quot;&gt;</p>
<p>3.自定义View</p>
<pre><code>getMeasuredWidth()、getMeasuredHeight()必须在onMeasure之后使用才有效

getWidth()与getHeight()方法必须在layout(int l, int t, int r, int b)执行之后才有效


	public final int getMeasuredWidth() {
        return mMeasuredWidth &amp; MEASURED_SIZE_MASK;
    }

    public final int getMeasuredHeight() {
        return mMeasuredHeight &amp; MEASURED_SIZE_MASK;
    }

    public final int getWidth() {
        return mRight - mLeft;
    }

    public final int getHeight() {
        return mBottom - mTop;
    }

    public final int getLeft() {
        return mLeft;
    }

    public final int getRight() {
        return mRight;
    }

    public final int getTop() {
        return mTop;
    }

    public final int getBottom() {
        return mBottom;
    }

整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法（这个方法巨长）开始的，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)，其核心也就是通过判断来选择顺序执行这三个方法中的哪个，如下：

private void performTraversals() {
    ......
    //最外层的根视图的widthMeasureSpec和heightMeasureSpec由来
    //lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    ......
    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    ......
    mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());
    ......
    mView.draw(canvas);
    ......
}


measure方法是final，子类只能调用onMeasure方法

public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    ......
    //回调onMeasure()方法
    onMeasure(widthMeasureSpec, heightMeasureSpec);
    ......
}


widthMeasureSpec由两部分组成，高2位表示MODE，定义在MeasureSpec类（View的内部类）中，有三种类型，MeasureSpec.EXACTLY表示确定大小， MeasureSpec.AT_MOST表示最大大小， MeasureSpec.UNSPECIFIED不确定。低30位表示size，也就是父View的大小。对于系统Window类的DecorVIew对象Mode一般都为MeasureSpec.EXACTLY ，而size分别对应屏幕宽高。对于子View来说大小是由父View和子View共同决定的。


protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}


public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    //通过MeasureSpec解析获取mode与size
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}

如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的规格。


protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}

上面说了View实际是嵌套的，而且measure是递归传递的，所以每个View都需要measure。实际能够嵌套的View一般都是ViewGroup的子类，所以在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量，measureChildren内部实质只是循环调用measureChild，measureChild和measureChildWithMargins的区别就是是否把margin和padding也作为子视图的大小。如下我们以ViewGroup中稍微复杂的measureChildWithMargins方法来分析：


protected void measureChildWithMargins(View child,
    int parentWidthMeasureSpec, int widthUsed,
    int parentHeightMeasureSpec, int heightUsed) {
    //获取子视图的LayoutParams
    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
    //调整MeasureSpec
    //通过这两个参数以及子视图本身的LayoutParams来共同决定子视图的测量规格
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                    + heightUsed, lp.height);
    //调运子View的measure方法，子View的measure中会回调子View的onMeasure方法
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}




layout部分
	View的layout，ViewGroup的layout实际是调用View的layout
 public void layout(int l, int t, int r, int b) {
    ......
    //实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量
    //判断View的位置是否发生过变化，以确定有没有必要对当前的View进行重新layout
    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    //需要重新layout
    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        //回调onLayout
        onLayout(changed, l, t, r, b);
        ......
    }
    ......
}

对比上面View的layout和ViewGroup的layout方法可以发现，View的layout方法是可以在子类重写的，而ViewGroup的layout是不能在子类重写的，言外之意就是说ViewGroup中只能通过重写onLayout方法。那我们接下来看下ViewGroup的onLayout方法，如下：



draw部分

	// Step 1, draw the background, if needed

		// skip step 2 &amp; 5 if possible (common case)

	// Step 2, save the canvas' layers
	// Step 3, draw the content
	// Step 4, draw the children
	// Step 5, draw the fade effect and restore layers
	// Step 6, draw decorations (scrollbars)


区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性（譬如对LinearLayout设置子View在显示时出现逐行、随机、下等显示等不同动画效果）。
</code></pre>
<p>4.View的invalidate和postInvalidate方法源码分析</p>
<pre><code>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。

在上面分析View的三步绘制流程中最后都有调运一个叫invalidate的方法

//看见上面注释没有？public，只能在UI Thread中使用，别的Thread用postInvalidate方法，View是可见的才有效，回调onDraw方法,针对局部View

 public void invalidate(Rect dirty) {
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    //实质还是调运invalidateInternal方法
    invalidateInternal(dirty.left - scrollX, dirty.top - scrollY,
            dirty.right - scrollX, dirty.bottom - scrollY, true, false);
}

//！！！！！！看见没有，这是所有invalidate的终极调运方法！！！！！！
void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
        boolean fullInvalidate) {
    ......
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) {
            final Rect damage = ai.mTmpInvalRect;
            //设置刷新区域
            damage.set(l, t, r, b);
            //传递调运Parent ViewGroup的invalidateChild方法
            p.invalidateChild(this, damage);
        }
        ......
}

这个过程最后传递到ViewRootImpl的invalidateChildInParent方法结束，所以我们看下ViewRootImpl的invalidateChildInParent方法，

 @Override
public ViewParent invalidateChildInParent(int[] location, Rect dirty) {
    ......
    //View调运invalidate最终层层上传到ViewRootImpl后最终触发了该方法
    scheduleTraversals();
    ......
    return null;
}

看见没有？这个ViewRootImpl类的invalidateChildInParent方法直接返回了null，也就是上面ViewGroup中说的，层层上级传递到ViewRootImpl的invalidateChildInParent方法结束了那个do while循环。看见这里调运的scheduleTraversals这个方法吗？scheduleTraversals会通过Handler的Runnable发送一个异步消息，调运doTraversal方法，然后最终调用performTraversals()执行重绘。开头背景知识介绍说过的，performTraversals就是整个View数开始绘制的起始调运地方，所以说View调运invalidate方法的实质是层层上传到父级，直到传递到ViewRootImpl后触发了scheduleTraversals方法，然后整个View树开始重新按照上面分析的View绘制流程进行重绘任务。



public void postInvalidate() {
    postInvalidateDelayed(0);
}


public void postInvalidateDelayed(long delayMilliseconds) {
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    //核心，实质就是调运了ViewRootImpl.dispatchInvalidateDelayed方法
    if (attachInfo != null) {
        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);
    }
}

我们继续看他调运的ViewRootImpl类的dispatchInvalidateDelayed方法，如下源码：

public void dispatchInvalidateDelayed(View view, long delayMilliseconds) {
    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);
    mHandler.sendMessageDelayed(msg, delayMilliseconds);
}

看见没有，通过ViewRootImpl类的Handler发送了一条MSG_INVALIDATE消息，继续追踪这条消息的处理可以发现：

public void handleMessage(Message msg) {
......
switch (msg.what) {
case MSG_INVALIDATE:
    ((View) msg.obj).invalidate();
    break;
......
}
......
</code></pre>
<p>}</p>
<p>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。
触发setSelection方法。请求重新draw，但只会绘制调用者本身。
触发setVisibility方法。 当View可视状态在INVISIBLE转换VISIBLE时会间接调用invalidate方法，继而绘制该View。当View的可视状态在INVISIBLE\VISIBLE 转换为GONE状态时会间接调用requestLayout和invalidate方法，同时由于View树大小发生了变化，所以会请求measure过程以及draw过程，同样只绘制需要“重新绘制”的视图。
触发setEnabled方法。请求重新draw，但不会重新绘制任何View包括该调用者本身。
触发requestFocus方法。请求View树的draw过程，只绘制“需要重绘”的View。</p>
<pre><code>requestLayout方法分析

	 public void requestLayout() {
        ......
        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) {
            //由此向ViewParent请求布局
            //从这个View开始向上一直requestLayout，最终到达ViewRootImpl的requestLayout
            mParent.requestLayout();
        }
        ......
    }


ViewRootImpl


 @Override
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        checkThread();
        mLayoutRequested = true;
        //View调运requestLayout最终层层上传到ViewRootImpl后最终触发了该方法
        scheduleTraversals();
    }
}


看见没有，类似于上面分析的invalidate过程，只是设置的标记不同，导致对于View的绘制流程中触发的方法不同而已。

requestLayout()方法会调用measure过程和layout过程，不会调用draw过程，也不会重新绘制任何View包括该调用者本身。


requestLayout：当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view重新调用他的onMeasure onLayout来对重新设置自己位置。
特别的当view的layoutparameter发生改变，并且它的值还没能应用到view上，这时候适合调用这个方法。
invalidate：View本身调用迫使view重画。</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题6/">
                Android面试6
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.高效加载大图片</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();  
options.inJustDecodeBounds = true;  
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);  
int imageHeight = options.outHeight;  
int imageWidth = options.outWidth;  
String imageType = options.outMimeType;  

那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。

public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  
    int reqWidth, int reqHeight) {  
    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  
    final BitmapFactory.Options options = new BitmapFactory.Options();  
    options.inJustDecodeBounds = true;  
    BitmapFactory.decodeResource(res, resId, options);  
    // 调用上面定义的方法计算inSampleSize值  
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  
    // 使用获取到的inSampleSize值再次解析图片  
    options.inJustDecodeBounds = false;  
    return BitmapFactory.decodeResource(res, resId, options);  
}  
</code></pre>
<p>2.map的内部实现
	Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();
	Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</p>
<p>3.Android 中Serializable与Parcelable区别？
	两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。</p>
<pre><code>1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；

2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&amp;~3)这句宏定义就是在做这件事情；

3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；

4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()
		 实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。


public static final Parcelable.Creator&lt;MyColor&gt; CREATOR  
    = new Parcelable.Creator&lt;MyColor&gt;() {  
    public MyColor createFromParcel(Parcel in) {  
        return new MyColor(in);  
    }  
      
    public MyColor[] newArray(int size) {  
        return new MyColor[size];  
    }  
};  


MyColor(Parcel in){  
    color=in.readInt();  
}  


@Override  
public void writeToParcel(Parcel dest, int flags) {  
    dest.writeInt(color);  
}  
</code></pre>
<p>4.Binder也与Parcel相关，都是使用的Parcel的write_和read_方法</p>
<pre><code>http://www.cnblogs.com/zhangxinyan/p/3487909.html

客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的

ublic static com.example.laozhu.aidl.Helo asInterface(proxy){
	return new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);
}

其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。
其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。

一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。

这三个tree都具体存写什么东西？
	--&gt;这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.

ProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。
</code></pre>
<p>&lt;img src=&quot;https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png&quot; alt=&quot;&quot;&gt;</p>
<pre><code>this.attachInterface(this, DESCRIPTOR);

而在onServiceConnected中的调用为：

mService = IBookManager.Stub.asInterface(service);

注意sercice为IBookManager.Stub，从而我们可以知道，

我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。

共享内存块</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题5/">
                Android面试5
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.String、StringBuffer、StringBuilder
	StringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的</p>
<p>2.Hnadler
	它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。</p>
<pre><code>首先来看看Handler的几个常见的构造方法，分别是：

	Handler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。

	Handler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）

	Handler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。

	public Handler(Looper looper, Callback callback, boolean async)

接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:

	定时执行messages 和 runnables；

	在将一个action入队并在其他线程中执行；

虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 

同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 

MessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。

Looper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。

class LooperThread extends Thread {
  	public Handler mHandler;

  	public void run() {
        Looper.prepare();

        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // process incoming messages here
            }
        };

        Looper.loop();
  	}
}

在Handler的构造方法中使用：
	mLooper = Looper.myLooper();//获取当前线程中的looper
	if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);
    }

首先是Looper.prepare()方法：
	sThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到
												其他线程，即它的值对于每个线程来说都是独立的。 
Looper构造方法：											
    private Looper(boolean quitAllowed) {
	    mQueue = new MessageQueue(quitAllowed);
	    mThread = Thread.currentThread();
	}

在handler的构造方法中使用，获取当前线程的looper
    public static Looper myLooper() {
        return sThreadLocal.get();
    }

使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息


不断地调用queue.next()从消息队列中获取消息：

	其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。


获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：

	public void More dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题4/">
                Android面试4
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.Dalvik虚拟机与java虚拟机的区别
	1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</p>
<pre><code>2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。

3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.
</code></pre>
<p>2.object的方法</p>
<pre><code>wheng fcnt
</code></pre>
<p>3.sleep和wait的区别有</p>
<pre><code>其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题

在java.lang.Thread类中，提供了sleep()，
而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程
sleep()可以将一个线程睡眠，参数可以指定一个时间。
而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。

1，这两个方法来自不同的类分别是Thread和Object
2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

synchronized(x){
  x.notify()
 //或者wait()
}

4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
</code></pre>
<ol start="4">
<li>
<p>Android事件分发机制完全解析</p>
<p>onTouch在onClick之前，onTouch返回true则onClick不响应</p>
<p>public boolean dispatchTouchEvent(MotionEvent event) {<br>
if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;<br>
mOnTouchListener.onTouch(this, event)) {<br>
return true;<br>
}<br>
return onTouchEvent(event);<br>
}</p>
</li>
</ol>
<pre><code>onTouchEvent方法中会调用onClick方法

onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。

问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？

	当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=&quot;true&quot;的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。


ViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。


事件传递机制  activity  -&gt; window -&gt;顶层容器(decorView) -&gt;view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法

1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。
2.正常情况下，一个事件序列只能被一个View拦截且消耗。
3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。
4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。
5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。
6.ViewGroup默认不拦截任何事件
7.View没有onInterceptTouchEvent方法
8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）
9.View的enable属性不影响onTouchEvent的默认返回值。
10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外
11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。
</code></pre>
<p>5.js与webView交互
	 &lt;script type=&quot;text/javascript&quot;&gt;<br>
var result = JavaScriptInterface.jsontohtml();<br>
var obj = eval(&quot;(&quot;+result+&quot;)&quot;);//解析json字符串<br>
function showAndroidToast(toast)<br>
{<br>
JavaScriptInterface.showToast(toast);<br>
}<br>
function getjsonData(){<br>
var result = JavaScriptInterface.jsontohtml();<br>
var obj = eval(&quot;(&quot;+result+&quot;)&quot;);//解析json字符串<br>
for(i=0;i&lt;obj.length;i++){<br>
var user=obj[i];<br>
document.write(&quot;&lt;p&gt;姓名:&quot;+user.name+&quot;&lt;/p&gt;&quot;);<br>
document.write(&quot;&lt;p&gt;年龄:&quot;+user.age+&quot;&lt;/p&gt;&quot;);<br>
document.write(&quot;&lt;p&gt;地址:&quot;+user.address+&quot;&lt;/p&gt;&quot;);<br>
if(user.phone!=null){<br>
document.write(&quot;&lt;p&gt;手机号码:&quot;+user.address+&quot;&lt;/p&gt;&quot;);<br>
}<br>
}<br>
}<br>
function list(){<br>
document.write(&quot;&lt;div data-role='header'&gt;&lt;p&gt;another&lt;/p&gt;&lt;/div&gt;&quot;);<br>
}<br>
&lt;/script&gt;</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题3/">
                Android面试3
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.Context
	Activity、Service、Application都是Context的子类
	Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。
	Application和Service、ContentProvider、BroadcastReceiver无法进行一下操作：
	1.show a Dialog
	2.start an Activity
	3.Layout Inflation</p>
<pre><code>启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐

在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用

ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。


凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。
</code></pre>
<p>2.JNI
	那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。</p>
<pre><code>1.Java的native方法怎么与C/C++中的函数链接起来?

2.JNI定义了与Java对应的数据类型，用于JNI编程?

3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。


public class AndroidJni {

    static{
        System.loadLibrary(&quot;main&quot;);
    }

    public native void dynamicLog();

    public native void staticLog();

}

这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。


静态注册native方法
	JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog 
	JNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法

	Java_PkgName_ClassName_NativeMethodName(包名+类名)

	两个固定的参数变量，分别是JNIEnv和jobject
	JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)

	jobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。

动态注册
	JNI_OnLoad函数

	JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}
	该函数返回的int表示当前使用的JNI的版本
	该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：
		DestroyJavaVM
		AttachCurrentThread
		DetachCurrentThread
		GetEnv
	这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：
		JNIEnv *env;
		if (jvm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {

		    return -1;
		}
	这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。

	获取Java对象，完成动态注册

		上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：

		jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)

		第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：

		jclass clz = env-&gt;FindClass(&quot;com/github/songnick/jni/AndroidJni&quot;);

		第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：

		typedef struct {
		    const char* name;//Java层native方法的名字
		    const char* signature;//Java层native方法的描述符
		    void*       fnPtr;//对应JNI函数的指针
		} JNINativeMethod;

		JNINativeMethod nativeMethod[] = {{"dynamicLog", "()V", (void*)nativeDynamicLog}};

		最后调用RegisterNative函数完成动态注册：

		env-&gt;RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));


JNIEnv结构体

	上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：

	..........
	jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)
	jboolean GetBooleanField(jobject obj, jfieldID fieldID)
	jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)
	CallVoidMethod(jobject obj, jmethodID methodID, ...)
	CallBooleanMethod(jobject obj, jmethodID methodID, ...)
	..........
</code></pre>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/04/09/一些特殊类/">一些特殊的类</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/09/OkHttp/">OkHttp</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/08/Android中当item数量超过一定大小RecyclerView高度固定/">Android中当item数量超过一定大小Recy</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/08/Java线程池的4中拒绝策略/">java线程池的4种拒绝模式</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/Android三方库/">Android三方库</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/python/">python</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Android源码学习/">Android源码学习</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/java基础学习/">java基础学习</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>