<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="来自贫穷小山村，但我想回去">
    

    <!--Author-->
    
        <meta name="author" content="塑料葫芦娃">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="生死看淡，不服就干"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="来自贫穷小山村，但我想回去" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="生死看淡，不服就干"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - 生死看淡，不服就干</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">生死看淡，不服就干</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题2/">
                Android面试2
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.算法
	冒泡排序：从后面开始，小的往上
	选择排序：选择最小的放到第一个
	插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比
	归并排序：分为2个一组，排序，而后在合并（N*log(N)）</p>
<p>2.进程保活手段
	黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）
	白色保活：启动前台Service
	灰色保活：利用系统的漏洞启动前台Service</p>
<p>3.进程间通信的方式
	AIDL
		通过bindService进行连接获取binder，数据的传送使用parcel</p>
<pre><code>	android.os.Parcel _data = android.os.Parcel.obtain();  
	android.os.Parcel _reply = android.os.Parcel.obtain();  

	mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  
	Stub.TRANSACTION_add代表方法是int类型
	_data.writeInt(x); 
	int t = _data.readInt();

	_reply.writeInt(f)

	服务端：binder.onTransact
	客户端：binder.transact


广播

Messenger 
	其实原理也是通过binder来实现的
</code></pre>
<p>4.加载大图
	BitmapRegionDecoder类的使用</p>
<p>5.图片的3级缓存
	内存缓存（LruCache）
		int maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存
		mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {<br>
@Override<br>
protected int sizeOf(String key, Bitmap bitmap) {<br>
return bitmap.getByteCount();<br>
}<br>
};</p>
<pre><code>    照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。

本地缓存（DiskLruCache）
	数据存放在 /sdcard/Android/data/应用包名/cache 
	有一个journal文件

	public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  
	open()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。
	当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/&lt;application package&gt;/cache 这个路径，而后者获取到的是 /data/data/&lt;application package&gt;/cache 这个路径。

（LruCache与DiskLruCache结合使用）
	http://blog.csdn.net/guolin_blog/article/details/34093441
	每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。
</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/04/面试题1/">
                Android面试1
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-04</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android面试/">Android面试</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>1.4种启动方式
2.service的两者启动方式：
	startService
	bindService --&gt; 使用serviceConnection监听获取相应的binder来调用service的服务</p>
<p>3.BroadcastReceiver的两者注册方式：
	静态注册 --&gt; 生命周期与应用无关，当应用关闭时仍监听广播
	动态注册 --&gt; 生命周期从被注册开始到应用结束或被unregister</p>
<pre><code>无序广播（sendBroadcast） --&gt; 所有广播接收器同时接收广播 
有序广播（sendOrderedBroadcast） --&gt; 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）
</code></pre>
<p>4.HttpClient和HttpUrlConnection的选择
	在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。</p>
<pre><code>HttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能

而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。
</code></pre>
<p>5.HTTP 和 HTTPS 的不同之处
	HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
	HTTP 是不安全的，而 HTTPS 是安全的
	HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
	在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层
	HTTP 无需加密，而 HTTPS 对传输的数据进行加密
	HTTP 无需证书，而 HTTPS 需要认证证书</p>
<pre><code>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。

HTTP 包含如下动作：

	浏览器打开一个 TCP 连接
	浏览器发送 HTTP 请求到服务器端
	服务器发送 HTTP 回应信息到浏览器
	TCP 连接关闭

SSL 包含如下动作：

	验证服务器端
	允许客户端和服务器端选择加密算法和密码，确保双方都支持
	验证客户端(可选)
	使用公钥加密技术来生成共享加密数据
	创建一个加密的 SSL 连接
	基于该 SSL 连接传递 HTTP 请求

对称密钥与非对称密钥一起使用：
	1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）

    2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；

    3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；

    4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

    5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。

CA（电子商务认证机构）认证作用： 
	在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。


	为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。
</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/21/线程池/">
                线程池原理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/java基础学习/">java基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h3>线程池</h3>
<h4>简介</h4>
<p>1.ExecutorService 有 submit( )、shutDown、invokeAll（与submit对应，只是多个callable的集合）</p>
<p>2.Future future = ExecutorService.submit(new FutureTask(callable));</p>
<p>2.ThreadPoolExecutor 继承自 ExecutorServcie</p>
<p>3.Executors 是创建ThreadPoolExecutor的工具类</p>
<p>4.newCachedThreadPool、newFixedThreadPool、newWorkStealingPool、newScheduledThreadPool、newSingleThreadExecutor、newSingleThreadScheduledExecutor</p>
<p>5.使用ThreadFactory创建thread</p>
<p>**When a new task is submitted in method {@link #execute(Runnable)},</p>
<ul>
<li>and fewer than corePoolSize threads are running, a new thread is</li>
<li>created to handle the request, even if other worker threads are</li>
<li>idle.  If there are more than corePoolSize but less than</li>
<li>maximumPoolSize threads running, a new thread will be created only</li>
<li>if the queue is full.  By setting corePoolSize and maximumPoolSize</li>
<li>the same, you create a fixed-size thread pool. By setting</li>
<li>maximumPoolSize to an essentially unbounded value such as {@code</li>
<li>Integer.MAX_VALUE}, you allow the pool to accommodate an arbitrary</li>
<li>number of concurrent tasks.**</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">if (addWorker(command, true))</span><br><span class="line">return;</span><br><span class="line">c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">int recheck = ctl.get();</span><br><span class="line">if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">reject(command);</span><br><span class="line">else if (workerCountOf(recheck) == 0)</span><br><span class="line">addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">reject(command);</span><br></pre></td></tr></table></figure></p>
<p>SynchronousQueue 没有缓冲队列，使用一一配对的方式，take和put搭配使用，有默认是不公平的，也就是后进先出
LinkedBlockingQueue 对于maximumPoolSize是没有用的
ArrayBlockingQueue</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量，它包含两个概念：</span><br><span class="line"></span><br><span class="line">workerCount：表明当前有效的线程数</span><br><span class="line">runState：表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying，Terminate五种状态。</span><br><span class="line">为了把这两种状态放到一个int值中保存，代码中限定了workerCount的值是2^29-1，因为还有五种状态需要表示，需要3位才能表示五种状态，所以会有29位来表示workerCount，而剩下的3位来表示当前线程池的状态。</span><br></pre></td></tr></table></figure></p>
<h4>几种ExecutorService的实现类</h4>
<p>1、newCachedThreadPool
初始没有核心线程，最大线程数没有限制，使用同步队列，有60秒的idle时间，当idle时间到了而thread还没有工作的话就讲该thread销毁，线程可重用。
These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.
多用于运行大量的短运行周期的异步任务。</p>
<p>new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,
TimeUnit.SECONDS,
new SynchronousQueue&lt;Runnable&gt;());</p>
<p>2、newFixedThreadPool
生成固定数量的核心线程数，最大线程数等于核心线程数
Creates a thread pool that reuses a fixed number of threads</p>
<p>new ThreadPoolExecutor(nThreads, nThreads,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue&lt;Runnable&gt;());</p>
<p>3、newScheduledThreadPool</p>
<p>进行延迟或周期性调用任务，使用ThreadPoolExecutor进行线程池创建。
内部有一个DelayedWorkQueue，该队列同时具有PriorityQueue（优先级大的元素会放到队首）和DelayQueue（如果队列里第一个元素的getDelay返回值大于0，则take调用会阻塞）的功能。
将传入的任务封装成ScheduledFutureTask，该类继承FutureTask
Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</p>
<p>new ScheduledThreadPoolExecutor(corePoolSize);</p>
<p>4、newSingleThreadExecutor
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>new FinalizableDelegatedExecutorService
(new ThreadPoolExecutor(1, 1,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue&lt;Runnable&gt;()));</p>
<p>5、newSingleThreadScheduledExecutor</p>
<p>就是前面两者功能的结合</p>
<p>new DelegatedScheduledExecutorService
(new ScheduledThreadPoolExecutor(1));</p>
<p>6、newWorkStealingPool</p>
<p>创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</p>
<p>new ForkJoinPool
(parallelism,
ForkJoinPool.defaultForkJoinWorkerThreadFactory,
null, true);</p>
<p>7、ForkJoinPool</p>
<p>支持大任务分解成小任务的线程池，这是Java8新增线程池，通常配合ForkJoinTask接口的子类RecursiveAction或RecursiveTask使用。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/26/点击图标启动activity的过程/">
                点击图标启动activity的过程
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-26</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android源码学习/">Android源码学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif" alt="enter image description here"></p>
<p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p>
<p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p>
<p>3.startActivityLocked --&gt;<br>
startActivityUncheckedLocked --&gt;
startActivityLocked --&gt;
resumeTopActivityLocked --&gt;
startPausingLocked
<strong>-binder-&gt;</strong>
<strong>ApplicationThreadProxy.schedulePauseActivity --&gt;</strong></p>
<p><strong>（下面的两行是message的传递）</strong>
ActivityThread.queueOrSendMessage --&gt;
H.handleMessage --&gt;</p>
<p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong></p>
<p><strong>-binder-&gt;</strong>
<strong>ActivityManagerProxy.activityPaused --&gt;</strong>
<strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） --&gt;</strong>
ActivityStack.completePauseLocked --&gt;</p>
<p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) --&gt;</p>
<p>ActivityStack.startSpecificActivityLocked --&gt;
<strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p>
<p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>
int pid = Process.start(&quot;android.app.ActivityThread&quot;,<br>
mSimpleProcessManagement ? app.processName : null, uid, uid,<br>
gids, debugFlags, null);</p>
<p><strong>ActivityThread.main（启动ActivityThread）</strong>
<strong>-binder-&gt;</strong>
ActivityManagerProxy.attachApplication</p>
<p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p>
<p><strong>ActivityStack.realStartActivityLocked</strong>
<strong>-binder-&gt;</strong>
<strong>ApplicationThreadProxy.scheduleLaunchActivity --&gt;</strong></p>
<p>ActivityThread.queueOrSendMessage --&gt;
<strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong></p>
<p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p>
<p><strong>ActivityThread.performLaunchActivity --&gt;</strong></p>
<p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong>
<strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong>
<strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong>
<strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong>
<strong>5最后还要调用MainActivity的onCreate函数</strong></p>
<p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p>
<p>一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p>
<p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>
<p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>
<p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>
<p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/06/python爬虫scrapy的使用/">
                python爬虫scrapy的使用
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-06</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://op0dvu7tu.bkt.clouddn.com/helo005.jpg" alt="enter image description here"></p>
<h3>简介</h3>
<p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p>
<h3>环境与安装</h3>
<p><strong>环境</strong></p>
<p>python -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）
scrapy -- 1.5.0 （这个是根据你的python版本来选择的）
twisted
wheel
pywin32</p>
<p><strong>安装python</strong>
这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000" target="_blank" rel="noopener">python安装</a></p>
<p><strong>安装scrapy</strong>
一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href="https://pypi.python.org/pypi/Scrapy/1.5.0" target="_blank" rel="noopener">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p>
<pre><code>pip install wheel
</code></pre>
<p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png" alt="|center"></p>
<p>而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png" alt="enter image description here"></p>
<p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png" alt="|center">
经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png" alt="pywin32">
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png" alt="|center">
同样使用命令行进行安装</p>
<pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whl
pip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl
</code></pre>
<p>安装好这些之后我们就可以来看下scrapy了
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png" alt="|center"></p>
<h3>scrapy初涉</h3>
<p>之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html</p>
<p>我们先通过下面命令行创建一个scrapy项目</p>
<pre><code>scrapy startproject heloScrapy
</code></pre>
<p>相应的文件结构如下图所示</p>
<p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png" alt="|center"></p>
<p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。
引入scrapy以及相应的request，并命名为demo</p>
<pre><code>import scrapy
from tutorial.items import TutorialItem
from scrapy.http import Request

class DmozSpider(scrapy.Spider):
    name = &quot;demo&quot;
    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]
    start_urls = [
    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;
    ]
</code></pre>
<p>此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。</p>
<p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p>
<pre><code>    def parse(self, response):
        filename = response.url.split(&quot;/&quot;)[-2]
        with open(filename, 'wb') as f:
            f.write(response.body)
        for sel in response.xpath('//ul/li'):
            item = TutorialItem()
            item['title'] = sel.xpath('a/text()').extract()
            item['link'] = sel.xpath('a/@href').extract()
            item['desc'] = sel.xpath('text()').extract()
            yield item

            if sel.xpath('a/@href').extract() == '':
                print('empty')
            else:
                if len(sel.xpath('a/@href').extract()) &gt; 0:
                    self.num = self.num + 1

                    print('helo%s' % (self.num))
                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)
</code></pre>
<p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p>
<pre><code>    with open(filename, 'wb') as f:
        f.write(response.body)
</code></pre>
<p>with as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p>
<pre><code>file = open(&quot;/tmp/foo.txt&quot;)
try:
    data = file.read()
finally:
    file.close()
</code></pre>
<p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p>
<pre><code>import scrapy

class TutorialItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    title = scrapy.Field()
    link = scrapy.Field()
    desc = scrapy.Field()
    pass
</code></pre>
<p>至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html</p>
<p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。</p>
<p>最后的最后就是下面这段代码了</p>
<pre><code> yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)
</code></pre>
<p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p>
<p>最后我们可以通过cmd输入一些命令来运行程序</p>
<pre><code>scrapy crawl demo
</code></pre>
<p>运行结果如下
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png" alt="enter image description here"></p>
<h3>总结</h3>
<p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/06/python抓妹子/">
                python爬虫初涉
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-06</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://op0dvu7tu.bkt.clouddn.com/helo004.jpg" alt="enter image description here"></p>
<h3>文章简介</h3>
<p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p>
<p><img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png" alt="enter image description here"></p>
<p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p>
<h3>环境介绍</h3>
<p>废话少说接下来就是我们的基础环境部分
<strong>1.Python -- 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p>
<p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p>
<p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下）</p>
<p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页</p>
<hr>
<p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p>
<hr>
<p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p>
<p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p>
<h3>模块的安装</h3>
<p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\python36”和“文件夹\python36\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p>
<p><strong>接下来就用指令安装模块</strong></p>
<pre><code> pip install requests   
 pip install beautifulsoup4  
 pip install lxml
</code></pre>
<p>大致结果就如下图所示
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png" alt="enter image description here"></p>
<p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p>
<h3>爬虫编写</h3>
<p><strong>首先我们先整理一下爬图片的步骤：</strong></p>
<p>1.我们需要一个目标网站（www.mzitu.com）
2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取
3.获取网页中的图片地址
4.下载图片到本地</p>
<p><strong>步骤1：</strong>
www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png" alt="enter image description here"></p>
<p><strong>步骤2：</strong>
推荐使用chrome浏览器来进行网页源码的查看
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png" alt="enter image description here"></p>
<p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p>
<p><strong>步骤3：</strong>
接下来我们就进入到某个链接里面去看图了
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png" alt="enter image description here">
相应图片的地址被包含在**div class='main-image'**中</p>
<p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图
<img src="http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png" alt="enter image description here">
着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在**div class=‘pagenavi’**中</p>
<p><strong>步骤4：</strong>
<strong>开始代码编写</strong></p>
<p>我们需要在代码中引入相应的模块</p>
<pre><code>import requests
from bs4 import BeautifulSoup
import os
</code></pre>
<p>获取起始网页内容</p>
<pre><code>html = self.request(url)
</code></pre>
<p>这里的request是下面的这个方法</p>
<pre><code>    def request(self, url):  ##这个函数获取网页的response 然后返回
        headers = {
        'User-Agent': &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}
        content = requests.get(url, headers=headers)

        return content
</code></pre>
<p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p>
<pre><code>all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')
for a in all_a:       
    title = a.get_text() #取出a标签的文本       
    href = a['href'] #取出a标签的href 属性，也就是套图地址
    self.html(href, &quot;e:\\pic\\&quot; + path)
</code></pre>
<p>相应的html方法</p>
<pre><code>    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址
        html = self.request(href)
        helo = BeautifulSoup(html.text, 'lxml').find_all('span')
        if len(helo) &lt; 10:
            return
        max_span = helo[10].get_text()
        for page in range(1, int(max_span) + 1):
            page_url = href + '/' + str(page)
            self.img(page_url, path)  ##调用img函数
</code></pre>
<p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p>
<pre><code>    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址
        img_html = self.request(page_url)
        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')
        if helo is not None:
            helo1 = helo.find('img')
            if helo1 is not None:
                # do some thing you need
                img_url = helo1['src']
                self.saveImg(img_url, path)

    def saveImg(self, url, path):
        getHeaders = {
            'Host': 'i.meizitu.net',
            'Connection': 'Keep-Alive',
            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
            'Upgrade-Insecure-Requests': '1',
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',
            'Referer': 'http://www.mzitu.com/',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'zh-CN,zh;q=0.9'
        }
        response = requests.get(url, headers=getHeaders)
        
        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取
            response = requests.get(url, headers=getHeaders, allow_redirects=False)
            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。
                name = url[-9:-4]
                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址
                response = requests.get(redirectUrl)
                fp = open(name + &quot;.jpg&quot;, 'ab')
                fp.write(response.content)
                fp.close()
        else:
            os.chdir(path)
            name = url[-9:-4]
            fp = open(name + &quot;.jpg&quot;, 'ab')
            fp.write(response.content)
            fp.close()
            self.picNum = self.picNum + 1
            print(self.picNum)
</code></pre>
<p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p>
<h3>总结</h3>
<p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p>
<p><strong>多线程代码</strong></p>
<pre><code>import requests
from bs4 import BeautifulSoup
import os
import threading
import threadpool


class mzitu():
    num = 0
    picNum = 0

    def all_url(self, url):
        self.cv = threading.Condition()
        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response
        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')

        task_pool = threadpool.ThreadPool(50)
        requests = threadpool.makeRequests(self.nice, all_a)
        for req in requests:
            task_pool.putRequest(req)
        task_pool.wait()

    def nice(self, a):
        title = a.get_text()
        path = str(title).replace(&quot;?&quot;, '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉
        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！
            os.chdir(&quot;e:\\pic\\&quot; + path)  ##切换到目录
            href = a['href']
            self.html(href, &quot;e:\\pic\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！

    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址
        html = self.request(href)
        helo = BeautifulSoup(html.text, 'lxml').find_all('span')
        if len(helo) &lt; 10:
            return
        max_span = helo[10].get_text()
        for page in range(1, int(max_span) + 1):
            page_url = href + '/' + str(page)
            self.img(page_url, path)  ##调用img函数

    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址
        img_html = self.request(page_url)
        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')
        if helo is not None:
            helo1 = helo.find('img')
            if helo1 is not None:
                # do some thing you need
                img_url = helo1['src']
                self.saveImg(img_url, path)

    def mkdir(self, path):  ##这个函数创建文件夹
        path = path.strip()
        if path.__contains__(&quot;妲己&quot;):
            return False
        isExists = os.path.exists(os.path.join(&quot;e:\\pic\\&quot;, path))
        if not isExists:
            os.makedirs(os.path.join(&quot;e:\\pic\\&quot;, path))
            return True
        else:
            return False

    def request(self, url):  ##这个函数获取网页的response 然后返回
        headers = {
            'User-Agent': &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}
        content = requests.get(url, headers=headers)

        return content

    def saveImg(self, url, path):
        getHeaders = {
            'Host': 'i.meizitu.net',
            'Connection': 'Keep-Alive',
            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
            'Upgrade-Insecure-Requests': '1',
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',
            'Referer': 'http://www.mzitu.com/',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'zh-CN,zh;q=0.9'
        }

        response = requests.get(url, headers=getHeaders)
        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取
            response = requests.get(url, headers=getHeaders, allow_redirects=False)
            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。
                name = url[-9:-4]
                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址
                response = requests.get(redirectUrl)
                fp = open(name + &quot;.jpg&quot;, 'ab')
                fp.write(response.content)
                fp.close()
        else:
            os.chdir(path)
            name = url[-9:-4]
            fp = open(name + &quot;.jpg&quot;, 'ab')
            fp.write(response.content)
            fp.close()
            self.picNum = self.picNum + 1
            print(self.picNum)
            
Mzitu = mzitu()  ##实例化
Mzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）
</code></pre>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/06/01/Android自动化测试/">
                Android自动化测试
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-06-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android基础学习/">Android基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg" alt="enter image description here"></p>
<hr>
<h3>摘要</h3>
<pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。
</code></pre>
<h3>Monkey测试</h3>
<h4>简介</h4>
<pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  
</code></pre>
<h4>使用方式</h4>
<pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   
（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  
（3）Monkey 命令启动方式：  
  
    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  
    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  
    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         
</code></pre>
<h4>效果展示</h4>
<p>部分输出数据如下所示：
<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png" alt="输出数据"></p>
<h4>更多参数介绍</h4>
<p><a href="http://blog.csdn.net/linghu_java/article/details/6732895" target="_blank" rel="noopener">点击查看</a></p>
<h4>可能会遇到的问题</h4>
<pre><code>（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  
</code></pre>
<p><a href="http://www.cnblogs.com/dwf07223/p/3228047.html" target="_blank" rel="noopener">点击查看解决方案</a></p>
<h3>单元测试</h3>
<h4>简介</h4>
<pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。
</code></pre>
<h4>使用方式</h4>
<pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：

dependencies {
    testCompile 'junit:junit:4.12'
}
</code></pre>
<p>而后在test文件下写单元测试类
<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png" alt="enter image description here"></p>
<p>被测试类如下</p>
<pre><code>public class Calculator {
    public static int add(int a, int b) {
        return a + b;
    }
}
</code></pre>
<p>单元测试类如下</p>
<pre><code>public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, Calculator.add(2,2));
    }
}
</code></pre>
<p>最后运行单元测试类，结果如下：</p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png" alt="enter image description here"></p>
<h4>Junit标签解析</h4>
<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>
<pre><code>@Test： 将方法（函数）标记为测试用例
@Before： 每一个使用@Test标记的方法运行之前都要运行一次
@After： 每一个使用@Test标记的方法运行之后都要运行一次
@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次
@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次
</code></pre>
<p>以如下代码为例：</p>
<pre><code>public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        System.out.println(&quot;@Test&quot;);
    }


    @Test
    public void addition_isErr() throws Exception {
        System.out.println(&quot;@Test&quot;);
    }

    @Before
    public void before() throws Exception {
        System.out.println(&quot;@Before&quot;);
    }

    @After
    public void after() throws Exception {
        System.out.println(&quot;@After&quot;);
    }


    @AfterClass
    public static void afterClass() throws Exception {
        System.out.println(&quot;@AfterClass&quot;);
    }

    @BeforeClass
    public static void beforeClass() throws Exception {
        System.out.println(&quot;@BeforeClass&quot;);
    }
}
</code></pre>
<p>相应的执行顺序如下：
<img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png" alt="enter image description here"></p>
<h4>Mockito使用方式</h4>
<p>简介：</p>
<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。
</code></pre>
<p><strong>先体验以下Mockito的使用：</strong></p>
<p>1.添加依赖</p>
<pre><code>testCompile 'org.mockito:mockito-core:2.8.47'
</code></pre>
<p>2.被依赖类</p>
<pre><code>public interface IMathUtils {
    public int abs(int num); // 求绝对值
}
</code></pre>
<p>3.依赖类</p>
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class MockTest {
    @Mock
    IMathUtils mathUtils;

    @Test
    public void mockTest() {

        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1

        int abs = mathUtils.abs(-1); // 输出结果 1

        Assert.assertEquals(abs, 1);// 测试通过
    }
}
</code></pre>
<p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>
<p>Mockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>
<p>上述的依赖类也可以使用如下方式来写：</p>
<pre><code>public class MockTest {

    @Mock
    IMathUtils iMathUtils ; 

    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 

    @Test
    public void mockTest()  {
        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1

        int abs = mathUtils.abs(-1); // 输出结果 1

        Assert.assertEquals(abs, 1);// 测试通过
    }
}
</code></pre>
<p>其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似</p>
<p><strong>Mock配置</strong></p>
<p>Mock有多种配置方式，如下所示：</p>
<pre><code>@Test
public void test1()  {
        //  创建 mock
        MyClass test = Mockito.mock(MyClass.class);

    // 自定义 getUniqueId() 的返回值
    when(test.getUniqueId()).thenReturn(43);

    // 在测试中使用mock对象
    assertEquals(test.getUniqueId(), 43);
}

// 返回多个值
@Test
public void testMoreThanOneReturnValue()  {
        Iterator i= mock(Iterator.class);
        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);
        String result=i.next()+&quot; &quot;+i.next();
        // 断言
        assertEquals(&quot;Mockito rocks&quot;, result);
}

// 如何根据输入来返回值
@Test
public void testReturnValueDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);
        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);
        // 断言
        assertEquals(1,c.compareTo(&quot;Mockito&quot;));
}

// 如何让返回值不依赖于输入
@Test
public void testReturnValueInDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo(anyInt())).thenReturn(-1);
        // 断言
        assertEquals(-1 ,c.compareTo(9));
}

// 根据参数类型来返回值
@Test
public void testReturnValueInDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo(isA(Todo.class))).thenReturn(0);
        // 断言
        Todo todo = new Todo(5);
        assertEquals(todo ,c.compareTo(new Todo(1)));
}
</code></pre>
<p>更多配置可以看下这个网站  <a href="http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html" target="_blank" rel="noopener">点击链接</a></p>
<h3>UI测试</h3>
<h4>简介</h4>
<pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。
</code></pre>
<h4>使用方式</h4>
<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>
<pre><code>testCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
testCompile 'com.android.support.test:runner:0.4.1'
</code></pre>
<p>2.在androidTest目录下创建测试类</p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png" alt="enter image description here"></p>
<p>3.被测试类（即activity之类的展示界面）
MainActivity.class</p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private EditText mEt;
    private TextView mTv;
    private Button mBtn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mEt = (EditText) findViewById(R.id.et);
        mTv = (TextView) findViewById(R.id.tv);
        mBtn = (Button) findViewById(R.id.btn);

        mBtn.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        mTv.setText(mEt.getText().toString());
    }
}
</code></pre>
<p>activity_main.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;

&lt;TextView
    android:id=&quot;@+id/tv&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_marginTop=&quot;15dp&quot;
    android:padding=&quot;10dp&quot;
    android:text=&quot;helo&quot; /&gt;

&lt;EditText
    android:id=&quot;@+id/et&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:layout_alignParentLeft=&quot;true&quot;
    android:layout_alignParentStart=&quot;true&quot;
    android:layout_alignParentTop=&quot;true&quot;
    android:layout_marginTop=&quot;75dp&quot; /&gt;

&lt;Button
    android:id=&quot;@+id/btn&quot;
    android:layout_width=&quot;80dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_below=&quot;@+id/et&quot;
    android:layout_centerHorizontal=&quot;true&quot;
    android:layout_marginTop=&quot;49dp&quot;
    android:text=&quot;sure&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>
<p>测试类
ExampleInstrumentedTest.class</p>
<pre><code>@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Rule
    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(
            MainActivity.class);

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),
                closeSoftKeyboard());
        onView(withId(R.id.btn)).perform(click());
    }
}
</code></pre>
<p>其中**onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。</p>
<p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="noopener">更多操作方式-1</a><br>
<a href="http://blog.csdn.net/eclipsexys/article/details/45622813" target="_blank" rel="noopener">更多操作方式-2</a></p>
<h4>标签解析</h4>
<pre><code>@Rule: 应用于成员变量
@ClassRule: 应用于测试类中的静态变量
两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。
	
@RunWith（AndroidJUnit4.class）：  用于修改测试运行器
</code></pre>
<h3>总结</h3>
<pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。
</code></pre>
<p>Android自动化测试</p>
<p>enter image description here</p>
<p>Android自动化测试
摘要
Monkey测试
简介
使用方式
效果展示
更多参数介绍
可能会遇到的问题
单元测试
简介
使用方式
Junit标签解析
Mockito使用方式
UI测试
简介
使用方式
标签解析
总结
摘要</p>
<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。
Monkey测试</p>
<p>简介</p>
<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>
使用方式</p>
<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>
（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>
（3）Monkey 命令启动方式：</p>
<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  
- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  
- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         
</code></pre>
<p>效果展示</p>
<p>部分输出数据如下所示：</p>
<p>输出数据</p>
<p>更多参数介绍</p>
<p>点击查看</p>
<p>可能会遇到的问题</p>
<p>（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>
点击查看解决方案</p>
<p>单元测试</p>
<p>简介</p>
<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。
使用方式</p>
<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>
<p>dependencies {
testCompile 'junit:junit:4.12'
}
而后在test文件下写单元测试类</p>
<p>enter image description here</p>
<p>被测试类如下</p>
<p>public class Calculator {
public static int add(int a, int b) {
return a + b;
}
}
单元测试类如下</p>
<p>public class ExampleUnitTest {
@Test
public void addition_isCorrect() throws Exception {
assertEquals(4, Calculator.add(2,2));
}
}
最后运行单元测试类，结果如下：</p>
<p>enter image description here</p>
<p>Junit标签解析</p>
<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>
<p>@Test： 将方法（函数）标记为测试用例
@Before： 每一个使用@Test标记的方法运行之前都要运行一次
@After： 每一个使用@Test标记的方法运行之后都要运行一次
@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次
@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次
以如下代码为例：</p>
<p>public class ExampleUnitTest {</p>
<pre><code>@Test
public void addition_isCorrect() throws Exception {
    System.out.println(&quot;@Test&quot;);
}


@Test
public void addition_isErr() throws Exception {
    System.out.println(&quot;@Test&quot;);
}

@Before
public void before() throws Exception {
    System.out.println(&quot;@Before&quot;);
}

@After
public void after() throws Exception {
    System.out.println(&quot;@After&quot;);
}


@AfterClass
public static void afterClass() throws Exception {
    System.out.println(&quot;@AfterClass&quot;);
}

@BeforeClass
public static void beforeClass() throws Exception {
    System.out.println(&quot;@BeforeClass&quot;);
}
</code></pre>
<p>}
相应的执行顺序如下：</p>
<p>enter image description here</p>
<p>Mockito使用方式</p>
<p>简介：</p>
<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。
先体验以下Mockito的使用：</p>
<p>1.添加依赖</p>
<p>testCompile 'org.mockito:mockito-core:2.8.47'
2.被依赖类</p>
<p>public interface IMathUtils {
public int abs(int num); // 求绝对值
}
3.依赖类</p>
<p>@RunWith(MockitoJUnitRunner.class)
public class MockTest {
@Mock
IMathUtils mathUtils;</p>
<pre><code>@Test
public void mockTest() {

    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1

    int abs = mathUtils.abs(-1); // 输出结果 1

    Assert.assertEquals(abs, 1);// 测试通过
}
</code></pre>
<p>}
可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>
<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>
<p>上述的依赖类也可以使用如下方式来写：</p>
<p>public class MockTest {</p>
<pre><code>@Mock
IMathUtils iMathUtils ; 

@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 

@Test
public void mockTest()  {
    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1

    int abs = mathUtils.abs(-1); // 输出结果 1

    Assert.assertEquals(abs, 1);// 测试通过
}
</code></pre>
<p>}
其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>
<p>Mock配置</p>
<p>Mock有多种配置方式，如下所示：</p>
<p>@Test
public void test1()  {
//  创建 mock
MyClass test = Mockito.mock(MyClass.class);</p>
<pre><code>// 自定义 getUniqueId() 的返回值
when(test.getUniqueId()).thenReturn(43);

// 在测试中使用mock对象
assertEquals(test.getUniqueId(), 43);
</code></pre>
<p>}</p>
<p>// 返回多个值
@Test
public void testMoreThanOneReturnValue()  {
Iterator i= mock(Iterator.class);
when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);
String result=i.next()+&quot; &quot;+i.next();
// 断言
assertEquals(&quot;Mockito rocks&quot;, result);
}</p>
<p>// 如何根据输入来返回值
@Test
public void testReturnValueDependentOnMethodParameter()  {
Comparable c= mock(Comparable.class);
when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);
when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);
// 断言
assertEquals(1,c.compareTo(&quot;Mockito&quot;));
}</p>
<p>// 如何让返回值不依赖于输入
@Test
public void testReturnValueInDependentOnMethodParameter()  {
Comparable c= mock(Comparable.class);
when(c.compareTo(anyInt())).thenReturn(-1);
// 断言
assertEquals(-1 ,c.compareTo(9));
}</p>
<p>// 根据参数类型来返回值
@Test
public void testReturnValueInDependentOnMethodParameter()  {
Comparable c= mock(Comparable.class);
when(c.compareTo(isA(Todo.class))).thenReturn(0);
// 断言
Todo todo = new Todo(5);
assertEquals(todo ,c.compareTo(new Todo(1)));
}
更多配置可以看下这个网站 点击链接</p>
<p>UI测试</p>
<p>简介</p>
<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。
使用方式</p>
<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>
<p>testCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
testCompile 'com.android.support.test:runner:0.4.1'
2.在androidTest目录下创建测试类</p>
<p>enter image description here</p>
<p>3.被测试类（即activity之类的展示界面）
MainActivity.class</p>
<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>
<pre><code>private EditText mEt;
private TextView mTv;
private Button mBtn;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mEt = (EditText) findViewById(R.id.et);
    mTv = (TextView) findViewById(R.id.tv);
    mBtn = (Button) findViewById(R.id.btn);

    mBtn.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    mTv.setText(mEt.getText().toString());
}
</code></pre>
<p>}
activity_main.xml</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;</p>
<p>&lt;TextView
android:id=&quot;@+id/tv&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_marginTop=&quot;15dp&quot;
android:padding=&quot;10dp&quot;
android:text=&quot;helo&quot; /&gt;</p>
<p>&lt;EditText
android:id=&quot;@+id/et&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;40dp&quot;
android:layout_alignParentLeft=&quot;true&quot;
android:layout_alignParentStart=&quot;true&quot;
android:layout_alignParentTop=&quot;true&quot;
android:layout_marginTop=&quot;75dp&quot; /&gt;</p>
<p>&lt;Button
android:id=&quot;@+id/btn&quot;
android:layout_width=&quot;80dp&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_below=&quot;@+id/et&quot;
android:layout_centerHorizontal=&quot;true&quot;
android:layout_marginTop=&quot;49dp&quot;
android:text=&quot;sure&quot; /&gt;
&lt;/RelativeLayout&gt;
测试类
ExampleInstrumentedTest.class</p>
<p>@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
@Rule
public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(
MainActivity.class);</p>
<pre><code>@Test
public void useAppContext() throws Exception {
    // Context of the app under test.
    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),
            closeSoftKeyboard());
    onView(withId(R.id.btn)).perform(click());
}
</code></pre>
<p>}
其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>
<p>更多操作方式-1
更多操作方式-2</p>
<p>标签解析</p>
<p>@Rule: 应用于成员变量
@ClassRule: 应用于测试类中的静态变量
两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>
<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器
总结</p>
<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。
7539
qqq2830
退出账号
当前文档
恢复至上次同步状态
删除文档
导出...
预览文档
分享链接
系统
设置
使用说明
快捷帮助
常见问题
关于</p>
<p>搜索文件
杂物 Android自动化测试
杂物 SwipeToLoadLayout
检查Evernote中的笔记版本</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/06/01/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟/">
                compileSdkVersion, minSdkVersion， targetSdkVersion的关系
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-06-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android基础学习/">Android基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://img.blog.csdn.net/20161130141617130" alt="这里写图片描述"></p>
<h2><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2>
<p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p>
<p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p>
<h2><strong>compileSdkVersion</strong></h2>
<p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p>
<p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）</p>
<p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p>
<p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p>
<h2><strong>minSdkVersion</strong></h2>
<p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p>
<p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p>
<p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p>
<p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p>
<p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p>
<h2><strong>targetSdkVersion</strong></h2>
<p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p>
<p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p>
<p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p>
<p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p>
<h2><strong>Gradle and SDK versions</strong></h2>
<p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 23</span><br><span class="line">  buildToolsVersion “23.0.1”</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class="line">    minSdkVersion 7</span><br><span class="line">    targetSdkVersion 23</span><br><span class="line">    versionCode 1</span><br><span class="line">    versionName “1.0”</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href="http://blog.csdn.net/qqq2830/article/details/53405699" target="_blank" rel="noopener">链接地址</a>。</p>
<p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p>
<p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p>
<h2><strong>总的来说三者的关系</strong></h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure></p>
<p><strong>理想化来说应该是这样：</strong></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion (lowest possible) &lt;= </span><br><span class="line">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure></p>
<p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p>
<p>期待您的加入 <a href="https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Google+ post</a> 和<a href="https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener"> Android Development Patterns Collection</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/06/01/Dagger2/">
                Dagger2全面解析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-06-01</span>
            
            
            
                <span class="category">
                    <a href="/categories/Android基础学习/">Android基础学习</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="http://op0dvu7tu.bkt.clouddn.com/timg.jpg" alt="enter image description here"></p>
<h3>Dagger2的好处</h3>
<ul>
<li>依赖的注入和配置独立于组件之外。</li>
<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>
<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>
</ul>
<h3>相关标签</h3>
<p><strong>@Inject、@Module、@Provide、@Component</strong></p>
<ul>
<li>
<p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>
</li>
<li>
<p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>
</li>
<li>
<p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>
</li>
<li>
<p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>
</li>
</ul>
<h3>标签使用方式</h3>
<p><strong>1.@Inject</strong></p>
<pre><code>public class User {  

    ....  
    ....  
    //在被依赖类中使用@Inject标记该类的构造方法
    @Inject  
    public User() {  
    }  
  
    ....  
    ....    
}  
</code></pre>
<hr>
<pre><code>public class MainActivity extends AppCompatActivity {  
	  
    //在依赖类中使用@Inject来注入被依赖类实例
    @Inject  
    User user;  
    @Inject  
    User user2;  
    private TextView tv;  
    private TextView tv2;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值
        DaggerActivityComponent.builder().build().inject(this);  
        tv = ((TextView) findViewById(R.id.tv));  
        tv2 = ((TextView) findViewById(R.id.tv2));  
        tv.setText(user.toString());  
        tv2.setText(user2.toString());  
    }  
} 
</code></pre>
<p><strong>2.@Component</strong></p>
<pre><code>@Component  
public interface ActivityComponent {  
    void inject(MainActivity activity);  
}  
</code></pre>
<p><strong>3.@Provider &amp; @Module</strong></p>
<pre><code>@Module  
public class UserModule {  
    @Provides
    User providesUser() {  
        return new User();  
    }  
}  
</code></pre>
<h3>注入方式</h3>
<ul>
<li>构造方法注入：在类的构造方法前面注释@Inject</li>
<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>
<li>函数方法注入：在函数前面注释@Inject</li>
</ul>
<h3>不同类的关系</h3>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png" alt="enter image description here"></p>
<h3>编译后的生成文件与原文件及关系图</h3>
<p><strong>原文件</strong>
<img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png" alt="enter image description here"></p>
<p><strong>生成文件</strong>
<img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png" alt="enter image description here"></p>
<p><strong>各文件对应关系</strong>
<img src="http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="enter image description here"></p>
<h3>注入路径</h3>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png" alt="enter image description here"></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png" alt="enter image description here"></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png" alt="enter image description here"></p>
<h3>@Scope（用于划分作用域）</h3>
<p><strong>javax包中自带的@Singleton,其class如下：</strong></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png" alt="enter image description here"></p>
<p><strong>用户自己写的</strong></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png" alt="enter image description here"></p>
<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>
<h4>各标签的意义</h4>
<p><strong>@Retention</strong></p>
<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:
1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略
2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略
3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>
<p><strong>@Documented</strong></p>
<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用</p>
<p><strong>@Scope</strong></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png" alt="enter image description here"></p>
<h3>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3>
<p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png" alt="enter image description here"></p>
<p><img src="http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png" alt="enter image description here"></p>
<h3>@Qualifier的巧用（指哪打哪）</h3>
<p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>
<p>两个@Qualifier</p>
<pre><code>@Qualifier
public @interface ThemeNight {

}

@Qualifier
public @interface ThemeDay {
}
</code></pre>
<hr>
<pre><code>@Module
public class ThemeModule {
    @Provides
    @ThemeDay
    Theme provideDayTheme() {
        return new Theme(&quot;day&quot;);
    }

    @Provides
    @ThemeNight
    Theme provideNightTheme() {
        return new Theme(&quot;night&quot;);
    }
}
</code></pre>
<hr>
<pre><code>@Component
public interface ThemeComponent{
    void inject(ThemeTest themeTest);
}
</code></pre>
<hr>
<pre><code>public class ThemeTest {
    @Inject
    @ThemeDay
    Theme dayTheme;
    @Inject
    @ThemeNight
    Theme nightTheme;

    public static void main(String[] arg) {
        ThemeTest themeTest = new ThemeTest();
        DaggerThemeComponent.create().inject(themeTest);
        System.out.println(themeTest.dayTheme.themeName);
        System.out.println(themeTest.nightTheme.themeName);
    }
}
</code></pre>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/04/09/一些特殊类/">一些特殊的类</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/09/OkHttp/">OkHttp</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/08/Android中当item数量超过一定大小RecyclerView高度固定/">Android中当item数量超过一定大小Recy</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/04/08/Java线程池的4中拒绝策略/">java线程池的4种拒绝模式</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/Android三方库/">Android三方库</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/python/">python</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Android源码学习/">Android源码学习</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/java基础学习/">java基础学习</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>